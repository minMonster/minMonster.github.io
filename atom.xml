<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bling</title>
  
  <subtitle>Monster&#39;s bling</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-30T04:42:37.606Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Monster</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim</title>
    <link href="http://yoursite.com/2018/04/09/Vim/"/>
    <id>http://yoursite.com/2018/04/09/Vim/</id>
    <published>2018-04-09T10:53:49.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /[string]</span><br></pre></td></tr></table></figure><p>向光标之下寻找一个名称为 word 的字符串。</p><p>例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ?[string]</span><br></pre></td></tr></table></figure><p>向光标之上寻找一个字符串名称为 word 的字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ n</span><br></pre></td></tr></table></figure><p>这个 n 是英文按键。代表重复前一个搜寻的动作。</p><p>举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ N</span><br></pre></td></tr></table></figure><p>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。</p><p>例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</p><blockquote><p>高端玩法请看 <a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">Vim</a> 搜索替换章节</p></blockquote><h3 id="删除、复制与贴上"><a href="#删除、复制与贴上" class="headerlink" title="删除、复制与贴上"></a>删除、复制与贴上</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ x, X</span><br></pre></td></tr></table></figure><p>在一行字当中，x 为向后删除一个字符 (相当于 del 按键)， X 为向前删除一个字符(相当于 backspace 亦即是退格键) (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [number]x</span><br></pre></td></tr></table></figure><p>number 为数字，连续向后删除 number 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd</span><br></pre></td></tr></table></figure><p>删除游标所在的那一整行(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [number]dd</span><br></pre></td></tr></table></figure><p>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ d1G</span><br></pre></td></tr></table></figure><p>删除光标所在到第一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dG</span><br></pre></td></tr></table></figure><p>删除光标所在到最后一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ d$</span><br></pre></td></tr></table></figure><p>删除游标所在处，到该行的最后一个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ d0</span><br></pre></td></tr></table></figure><p>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yy</span><br></pre></td></tr></table></figure><p>复制游标所在的那一行(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nyy</span><br></pre></td></tr></table></figure><p>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ y1G</span><br></pre></td></tr></table></figure><p>复制游标所在行到第一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yG</span><br></pre></td></tr></table></figure><p>复制游标所在行到最后一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ y0</span><br></pre></td></tr></table></figure><p>复制光标所在的那个字符到该行行首的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ y$</span><br></pre></td></tr></table></figure><p>复制光标所在的那个字符到该行行尾的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ p, P</span><br></pre></td></tr></table></figure><p>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ J</span><br></pre></td></tr></table></figure><p>将光标所在行与下一行的数据结合成同一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ c</span><br></pre></td></tr></table></figure><p>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ u</span><br></pre></td></tr></table></figure><p>复原前一个动作。(常用)</p><p>[Ctrl]+r    重做上一个动作。(常用)<br>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .</span><br></pre></td></tr></table></figure><p>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</p>]]></content>
    
    <summary type="html">
    
      抄录于菜鸟教程
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>WebStrom 快捷键</title>
    <link href="http://yoursite.com/2018/02/24/WebStrom-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/02/24/WebStrom-快捷键/</id>
    <published>2018-02-24T10:53:49.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <summary type="html">
    
      一堆神奇的快捷键
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>理解Object.defineProperty的作用</title>
    <link href="http://yoursite.com/2018/02/24/%E7%90%86%E8%A7%A3Object-defineProperty%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/24/理解Object-defineProperty的作用/</id>
    <published>2018-02-24T10:49:30.000Z</published>
    <updated>2018-04-30T04:42:37.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解Object-defineProperty的作用"><a href="#理解Object-defineProperty的作用" class="headerlink" title="理解Object.defineProperty的作用"></a>理解Object.defineProperty的作用</h1><ul><li>对象是由多个名/值对组成的无序的集合。对象中每个属性对应任意类型的值。</li><li><p>定义对象可以使用构造函数或字面量的形式：</p><pre><code>var obj = new Object;  //obj = {}obj.name = &quot;张三&quot;;  //添加描述obj.say = function(){};  //添加行为</code></pre><p>除了以上添加属性的方式，还可以使用Object.defineProperty定义新属性或修改原有的属性。</p></li></ul><hr><blockquote><p>Object.defineProperty()<br>语法：</p><p>Object.defineProperty(obj, prop, descriptor)<br>参数说明：</p></blockquote><ul><li>obj：必需。目标对象</li><li>prop：必需。需定义或修改的属性的名字</li><li><p>descriptor：必需。目标属性所拥有的特性<br>返回值：</p></li><li><p>传入函数的对象。即第一个参数obj<br>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历。</p></li><li><p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p></li><li><p>数据描述<br>当修改或定义对象的某个属性的时候，给这个属性添加一些特性：</p><pre><code>var obj = {    test:&quot;hello&quot;}//对象已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});//对象新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});</code></pre></li><li><p>数据描述中的属性都是可选的，来看一下设置每一个属性的作用。</p></li></ul><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><ul><li><p>属性对应的值,可以使任意类型的值，默认为undefined</p><pre><code>var obj = {}//第一种情况：不设置value属性Object.defineProperty(obj,&quot;newKey&quot;,{});console.log( obj.newKey );  //undefined------------------------------//第二种情况：设置value属性Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;});console.log( obj.newKey );  //hellowritable</code></pre></li></ul><h2 id="属性的值是否可以被重写。"><a href="#属性的值是否可以被重写。" class="headerlink" title="属性的值是否可以被重写。"></a>属性的值是否可以被重写。</h2><ul><li><p>设置为true可以被重写；设置为false，不能被重写。默认为false。</p><pre><code>var obj = {}//第一种情况：writable设置为false，不能重写。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //hello//第二种情况：writable设置为true，可以重写Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //change valueenumerable</code></pre></li><li><p>此属性是否可以被枚举（使用for…in或Object.keys()）。</p></li><li><p>设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p><pre><code>var obj = {}//第一种情况：enumerable设置为false，不能被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false});//枚举对象的属性for( var attr in obj ){    console.log( attr );}//第二种情况：enumerable设置为true，可以被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:true});//枚举对象的属性for( var attr in obj ){    console.log( attr );  //newKey}</code></pre></li></ul><h2 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h2><ul><li>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。</li><li>设置为true可以被删除或可以重新设置特性；</li><li>设置为false，不能被可以被删除或不可以重新设置特性。默认为false。</li></ul><p><strong>这个属性起到两个作用：</strong></p><p>目标属性是否可以使用delete删除<br>目标属性是否可以再次设置特性</p><pre><code>//-----------------测试目标属性是否能被删除------------------------var obj = {}//第一种情况：configurable设置为false，不能被删除。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:false});//删除属性delete obj.newKey;console.log( obj.newKey ); //hello//第二种情况：configurable设置为true，可以被删除。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:true});//删除属性delete obj.newKey;console.log( obj.newKey ); //undefined//-----------------测试是否可以再次修改特性------------------------var obj = {}//第一种情况：configurable设置为false，不能再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:false});//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true,    enumerable:true,    configurable:true});console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey//第二种情况：configurable设置为true，可以再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:true});//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true,    enumerable:true,    configurable:true});console.log( obj.newKey ); //hello除了可以给新定义的属性设置特性，也可以给已有的属性设置特性//定义对象的时候添加的属性，是可删除、可重写、可枚举的。var obj = {    test:&quot;hello&quot;}//改写值obj.test = &apos;change value&apos;;console.log( obj.test ); //&apos;change value&apos;Object.defineProperty(obj,&quot;test&quot;,{    writable:false})//再次改写值obj.test = &apos;change value again&apos;;console.log( obj.test ); //依然是：&apos;change value&apos;提示：一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的falsevar obj = {};//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性//Object.defineProperty(obj,&apos;newKey&apos;,{});//设置值obj.newKey = &apos;hello&apos;;console.log(obj.newKey);  //undefined//枚举for( var attr in obj ){    console.log(attr);}</code></pre><h2 id="设置的特性总结："><a href="#设置的特性总结：" class="headerlink" title="设置的特性总结："></a>设置的特性总结：</h2><blockquote><p>value: 设置属性的值</p><p>writable: 值是否可以重写。true | false</p><p>enumerable: 目标属性是否可以被枚举。true | false</p><p>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | &gt; false</p><p>存取器描述<br>当使用存取器描述属性的特性的时候，允许设置以下特性属性：</p></blockquote><pre><code>var obj = {};Object.defineProperty(obj,&quot;newKey&quot;,{    get:function (){} | undefined,    set:function (value){} | undefined    configurable: true | false    enumerable: true | false});</code></pre><p><strong>注意：当使用了getter或setter方法，不允许使用writable和value这两个属性</strong></p><h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h2><p>当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。</p><p>getter 是一种获得属性值的方法<br>setter是一种设置属性值的方法。<br>在特性中使用get/set属性来定义对应的方法。</p><pre><code>var obj = {};var initValue = &apos;hello&apos;;Object.defineProperty(obj,&quot;newKey&quot;,{    get:function (){        //当获取值的时候触发的函数        return initValue;    },    set:function (value){        //当设置值的时候触发的函数,设置的新值通过参数value拿到        initValue = value;    }});//获取值console.log( obj.newKey );  //hello//设置值obj.newKey = &apos;change value&apos;;console.log( obj.newKey ); //change value</code></pre><p><strong>注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined</strong></p><p>configurable和enumerable同上面的用法。</p>]]></content>
    
    <summary type="html">
    
      理解Object.defineProperty的作用
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
      <category term="JS-Object" scheme="http://yoursite.com/tags/JS-Object/"/>
    
  </entry>
  
  <entry>
    <title>URL网址解析的好帮手</title>
    <link href="http://yoursite.com/2018/02/24/URL%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A5%BD%E5%B8%AE%E6%89%8B/"/>
    <id>http://yoursite.com/2018/02/24/URL网址解析的好帮手/</id>
    <published>2018-02-24T10:28:38.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URI简介"><a href="#URI简介" class="headerlink" title="URI简介:"></a>URI简介:</h2><p>URI统一资源标识符<br>URL统一资源定位符<br>URL是URI的子集，URL肯定是URI,URI不一定是URL</p><h2 id="url地址组成"><a href="#url地址组成" class="headerlink" title="url地址组成:"></a>url地址组成:</h2><p><strong>protbcol</strong>:指定底层使用协议，http或ftp等<br><strong>slashes</strong>:是否有协议的双斜线<br><strong>host</strong>:http的IP地址或域名<br><strong>port</strong>:端口<br><strong>hostname</strong>:主机名<br><strong>hash</strong>:哈希值<br><strong>search</strong>:查询字符串参数<br><strong>query</strong>:发送给http的数据，参数串<br><strong>pathname</strong>:访问资源路径名<br><strong>path</strong>:路径<br><strong>href</strong>:超链接</p><h2 id="解析url"><a href="#解析url" class="headerlink" title="解析url:"></a>解析url:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ url.parse(URL)</span><br><span class="line"></span><br><span class="line">$ url.parse(<span class="string">'https://www.imooc.com/course/list?c=nodejs'</span>)</span><br><span class="line"></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">'https:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'www.imooc.com'</span>,</span><br><span class="line">  port: null,</span><br><span class="line">  hostname: <span class="string">'www.imooc.com'</span>,</span><br><span class="line">  <span class="built_in">hash</span>: null,</span><br><span class="line">  search: <span class="string">'?c=nodejs'</span>,</span><br><span class="line">  query: <span class="string">'c=nodejs'</span>,</span><br><span class="line">  pathname: <span class="string">'/course/list'</span>,</span><br><span class="line">  path: <span class="string">'/course/list?c=nodejs'</span>,</span><br><span class="line">  href: <span class="string">'https://www.imooc.com/course/list?c=nodejs'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反解析"><a href="#反解析" class="headerlink" title="反解析:"></a>反解析:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format(OBJ)</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(obj,para1,para2)//将对象转化成url中query部分的形式（序列化）</span><br></pre></td></tr></table></figure><p>参数：<br>    1.要转化的对象<br>    2.链接符（默认&amp;）<br>    3.键与值之间的符号（默认=）</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">querystring.parse(string,para1,para2)//将query字符串转化成对象（反序列化）</span><br></pre></td></tr></table></figure><p>参数：<br>    1.query字符串<br>    2.链接符（默认&amp;）<br>    3.键与值之间的符号（默认=）<br>    4.参数的个数（默认最多1000个，0就没有限制）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">querystring.escape(string)//文字转译</span><br><span class="line">querystring.unescape(string)//反转译</span><br></pre></td></tr></table></figure></p><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>DNS 域名系统 (Domain Name System) 的缩写</p><p>http客户端发起请求，创建端口<br>http服务器在端口监听客户端请求<br>http服务器向客户端返回状态和内容<br>请求和响应都发送 http 头和正文信息，http 头发送内容类型、http 状态码，正文是提交的数据或者服务器返回的数据<br>1.chrome搜索自身的DNS缓存<br>2.搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）<br>3.读取本地的host文件<br>4.浏览器发起一个DNS的一个系统调用：①宽带运营商服务器查看本身缓存；②运营商服务器发起一个迭代DNS解析的请求；③运营商服务器把结果返回操作系统内核同时缓存起来，④操作系统内核把结果返回浏览器；⑤最终浏览器拿到了目标网站对应的IP地址<br>5.浏览器获得域名对应ip地址后，发起HTTP“三次握手”<br>6.TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了。<br>7.服务器端接受到这个请求，根据路径参数，经过后端处理后，把处理后的一个结果的数据返回给浏览器。<br>8.浏览器获取到目标网址的数据，例如返回一个HTML文件,HTML文档内的JS/CSS/图片静态资源同样也是一个个HTTP请求，也要包括上述步骤。<br>9.浏览器根据获取到的资源对页面进行渲染，最终把网页呈献给用户</p><h2 id="http头和正文信息"><a href="#http头和正文信息" class="headerlink" title="http头和正文信息"></a>http头和正文信息</h2><p>HTTP头发送的是一些附加的信息：内容类型、服务器发送相应的日期、HTTP状态码</p><p>正文就是用户提交的表单数据。</p>]]></content>
    
    <summary type="html">
    
      node 中 url 解析以及反解析
    
    </summary>
    
      <category term="NodeJs" scheme="http://yoursite.com/categories/NodeJs/"/>
    
    
      <category term="后端开发" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信JSDK开发问题总结</title>
    <link href="http://yoursite.com/2018/02/24/%E5%BE%AE%E4%BF%A1JSDK%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/24/微信JSDK开发问题总结/</id>
    <published>2018-02-24T10:08:36.000Z</published>
    <updated>2018-04-30T04:42:37.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤一：绑定域名"><a href="#步骤一：绑定域名" class="headerlink" title="步骤一：绑定域名"></a>步骤一：绑定域名</h2><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。<br>备注：登录后可在“开发者中心”查看对应的接口权限。</p><h2 id="步骤二：引入JS文件"><a href="#步骤二：引入JS文件" class="headerlink" title="步骤二：引入JS文件"></a>步骤二：引入JS文件</h2><p>Github地址 <a href="https://github.com/yanxi-me/weixin-js-sdk" target="_blank" rel="noopener">https://github.com/yanxi-me/weixin-js-sdk</a><br>在需要调用JS接口的页面引入如下JS文件（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.2.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.2.0.js</a><br>备注：支持使用 AMD/CMD 标准模块加载方法加载</p><h2 id="步骤三：通过config接口注入权限验证配置"><a href="#步骤三：通过config接口注入权限验证配置" class="headerlink" title="步骤三：通过config接口注入权限验证配置"></a>步骤三：通过config接口注入权限验证配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$wx</span>.config(&#123;</span><br><span class="line">  debug: <span class="literal">false</span>, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过<span class="built_in">log</span>打出，仅在pc端时才会打印。</span><br><span class="line">  appId: APPID, // 必填，公众号的唯一标识</span><br><span class="line">  timestamp: data[<span class="string">'timestamp'</span>], // 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: data[<span class="string">'noncestr'</span>], // 必填，生成签名的随机串</span><br><span class="line">  signature: data[<span class="string">'signature'</span>], // 必填，签名，见附录1</span><br><span class="line">  jsApiList: [<span class="string">'scanQRCode'</span>] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调试的时候一定要打开 debug 看报错检查问题</p><h2 id="步骤四：通过ready接口处理成功验证"><a href="#步骤四：通过ready接口处理成功验证" class="headerlink" title="步骤四：通过ready接口处理成功验证"></a>步骤四：通过ready接口处理成功验证</h2><p>wx.ready(function(){<br>    // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。<br>});</p><h2 id="步骤五：通过error接口处理失败验证"><a href="#步骤五：通过error接口处理失败验证" class="headerlink" title="步骤五：通过error接口处理失败验证"></a>步骤五：通过error接口处理失败验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wx.error(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">    // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">&#125;);</span><br><span class="line">this.<span class="variable">$wx</span>.checkJsApi(&#123;</span><br><span class="line">  jsApiList: [</span><br><span class="line">    <span class="string">'scanQRCode'</span></span><br><span class="line">  ],</span><br><span class="line">  success: <span class="keyword">function</span> (res) &#123;</span><br><span class="line">    console.log(JSON.stringify(res))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">this.<span class="variable">$wx</span>.scanQRCode(&#123;</span><br><span class="line">  needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，</span><br><span class="line">  scanType: [<span class="string">'qrCode'</span>, <span class="string">'barCode'</span>], // 可以指定扫二维码还是一维码，默认二者都有</span><br><span class="line">  success: <span class="keyword">function</span> (res) &#123;</span><br><span class="line">    <span class="built_in">let</span> result = res.resultStr // 当needResult 为 1 时，扫码返回的结果</span><br><span class="line">    console.log(result)</span><br><span class="line">    alert(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>重点：一定要检查 appid 是否与后台相同</strong><br><strong>一定要检查当前插件是否能够启用</strong></p>]]></content>
    
    <summary type="html">
    
      微信JSDK开发问题总结
    
    </summary>
    
      <category term="微信" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2018/01/31/python/"/>
    <id>http://yoursite.com/2018/01/31/python/</id>
    <published>2018-01-31T09:50:48.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中数据类型"><a href="#Python中数据类型" class="headerlink" title="Python中数据类型"></a>Python中数据类型</h1><h2 id="一、整数"><a href="#一、整数" class="headerlink" title="一、整数"></a>一、整数</h2><p> Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><h2 id="二、浮点数"><a href="#二、浮点数" class="headerlink" title="二、浮点数"></a>二、浮点数</h2><p> 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p> 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h2 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h2><p> 字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p><h2 id="四、布尔值"><a href="#四、布尔值" class="headerlink" title="四、布尔值"></a>四、布尔值</h2><p> 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p><p> 布尔值可以用and、or和not运算。</p><p> and运算是与运算，只有所有都为 True，and运算结果才是 True。</p><p> or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p><p> not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p><h2 id="五、空值"><a href="#五、空值" class="headerlink" title="五、空值"></a>五、空值</h2><p> 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><p> 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到</p><hr><hr><h1 id="Python之print语句"><a href="#Python之print语句" class="headerlink" title="Python之print语句"></a>Python之print语句</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'hello, python.'</span>)</span><br><span class="line">hello, python</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello,'</span> + <span class="string">'python.'</span>)</span><br><span class="line">hello, python</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python的注释"><a href="#Python的注释" class="headerlink" title="Python的注释"></a>Python的注释</h1><p> 任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。</p><p> Python的注释以 # 开头，后面的文字直到行尾都算注释</p><hr><hr><h1 id="Python中什么是变量"><a href="#Python中什么是变量" class="headerlink" title="Python中什么是变量"></a>Python中什么是变量</h1><p> 在Python中，变量的概念基本上和初中代数的方程变量是一致的。</p><p> 例如，对于方程式 y=x*x ，x就是变量。当x=2时，计算结果是4，当x=5时，计算结果是25。</p><p> 只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p> 在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line"><span class="built_in">print</span>(a) // 1</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中定义字符串"><a href="#Python中定义字符串" class="headerlink" title="Python中定义字符串"></a>Python中定义字符串</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python was started in 1989 by \"Guido\".\nPython is free and easy to learn.'</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line"></span><br><span class="line">Python was started <span class="keyword">in</span> 1989 by <span class="string">"Guido"</span>.</span><br><span class="line">Python is free and easy to learn.</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中raw字符串与多行字符串"><a href="#Python中raw字符串与多行字符串" class="headerlink" title="Python中raw字符串与多行字符串"></a>Python中raw字符串与多行字符串</h1><p> 如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r<span class="string">'\(~_~)/ \(~_~)/'</span></span><br></pre></td></tr></table></figure><p> 但是r’…’表示法不能表示多行字符串，也不能表示包含’和 “的字符串（为什么？）</p><p> 如果要表示多行字符串，可以用’’’…’’’表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'Line 1</span></span><br><span class="line"><span class="string">Line 2</span></span><br><span class="line"><span class="string">Line 3'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p> 还可以在多行字符串前面添加 r ，把这个多行字符串也变成一个raw字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r<span class="string">''</span><span class="string">'Python is created by "Guido".</span></span><br><span class="line"><span class="string">It is free and easy to learn.</span></span><br><span class="line"><span class="string">Let'</span>s start learn Python <span class="keyword">in</span> imooc!<span class="string">''</span><span class="string">'</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中Unicode字符串"><a href="#Python中Unicode字符串" class="headerlink" title="Python中Unicode字符串"></a>Python中Unicode字符串</h1><p> 字符串还有一个编码问题。</p><p> 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。</p><p> 如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p><p> 类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p> Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p><p> 因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。</p><p> Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> u<span class="string">'中文'</span></span><br><span class="line">中文</span><br></pre></td></tr></table></figure><p> 注意: 不加 u ，中文就不能正常显示。<br> Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p><p> 转义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u<span class="string">'中文\n日文\n韩文'</span></span><br></pre></td></tr></table></figure><p> 多行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u<span class="string">''</span><span class="string">'第一行</span></span><br><span class="line"><span class="string">第二行'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p> raw+多行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ur<span class="string">''</span><span class="string">'Python的Unicode字符串支持"中文",</span></span><br><span class="line"><span class="string">"日文",</span></span><br><span class="line"><span class="string">"韩文"等多种语言'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p> 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p> 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">''</span><span class="string">'静夜思</span></span><br><span class="line"><span class="string">床前明月光，</span></span><br><span class="line"><span class="string">疑是地上霜。</span></span><br><span class="line"><span class="string">举头望明月，</span></span><br><span class="line"><span class="string">低头思故乡。'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中整数和浮点数"><a href="#Python中整数和浮点数" class="headerlink" title="Python中整数和浮点数"></a>Python中整数和浮点数</h1><p> Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。</p><p> 基本的运算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 + 3   <span class="comment"># ==&gt; 6</span></span><br><span class="line">4 * 5 - 6   <span class="comment"># ==&gt; 14</span></span><br><span class="line">7.5 / 8 + 2.1   <span class="comment"># ==&gt; 3.0375</span></span><br></pre></td></tr></table></figure><p> 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1 + 2) * 3    <span class="comment"># ==&gt; 9</span></span><br><span class="line">(2.2 + 3.3) / (1.5 * (9 - 0.3))    <span class="comment"># ==&gt; 0.42145593869731807</span></span><br></pre></td></tr></table></figure><p> 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 2    <span class="comment"># ==&gt; 整数 3</span></span><br><span class="line">1.0 + 2.0    <span class="comment"># ==&gt; 浮点数 3.0</span></span><br></pre></td></tr></table></figure><p> 但是整数和浮点数混合运算的结果就变成浮点数了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2.0    <span class="comment"># ==&gt; 浮点数 3.0</span></span><br></pre></td></tr></table></figure><p> 为什么要区分整数运算和浮点数运算呢？这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如 0.1 换成二进制表示就是无限循环小数。</p><p> 那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 / 4    <span class="comment"># ==&gt; 2</span></span><br></pre></td></tr></table></figure><p> 令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 % 4    <span class="comment"># ==&gt; 3</span></span><br></pre></td></tr></table></figure><p> 如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11.0 / 4    <span class="comment"># ==&gt; 2.75</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中布尔类型"><a href="#Python中布尔类型" class="headerlink" title="Python中布尔类型"></a>Python中布尔类型</h1><p> 我们已经了解了Python支持布尔类型的数据，布尔类型只有True和False两种值，但是布尔类型有以下几种运算：</p><p> 与运算：只有两个布尔值都为 True 时，计算结果才为 True。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True and True   <span class="comment"># ==&gt; True</span></span><br><span class="line">True and False   <span class="comment"># ==&gt; False</span></span><br><span class="line">False and True   <span class="comment"># ==&gt; False</span></span><br><span class="line">False and False   <span class="comment"># ==&gt; False</span></span><br></pre></td></tr></table></figure><p> 或运算：只要有一个布尔值为 True，计算结果就是 True。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True or True   <span class="comment"># ==&gt; True</span></span><br><span class="line">True or False   <span class="comment"># ==&gt; True</span></span><br><span class="line">False or True   <span class="comment"># ==&gt; True</span></span><br><span class="line">False or False   <span class="comment"># ==&gt; False</span></span><br></pre></td></tr></table></figure><p> 非运算：把True变为False，或者把False变为True：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">not True   <span class="comment"># ==&gt; False</span></span><br><span class="line">not False   <span class="comment"># ==&gt; True</span></span><br></pre></td></tr></table></figure><p> 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。</p><p> 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = True</span><br><span class="line"><span class="built_in">print</span> a and <span class="string">'a=T'</span> or <span class="string">'a=F'</span></span><br></pre></td></tr></table></figure><p> 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？</p><p> 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以：</p><p> True and ‘a=T’ 计算结果是 ‘a=T’<br> 继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’<br> 要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。</p><blockquote><ol><li><p>在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。</p></li><li><p>在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。</p></li></ol></blockquote><p> 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。</p>]]></content>
    
    <summary type="html">
    
      python 学习小文档
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>cordova</title>
    <link href="http://yoursite.com/2018/01/29/cordova/"/>
    <id>http://yoursite.com/2018/01/29/cordova/</id>
    <published>2018-01-29T03:04:13.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cordova中文文档"><a href="#cordova中文文档" class="headerlink" title="cordova中文文档"></a><a href="http://cordova.axuer.com/docs/zh-cn/latest/" title="cordova中文文档" target="_blank" rel="noopener">cordova</a>中文文档</h1><h2 id="安装-cordova"><a href="#安装-cordova" class="headerlink" title="安装 cordova"></a>安装 cordova</h2><p>Cordova命令行工具作为npm包分发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cordova -g</span><br></pre></td></tr></table></figure><h2 id="创建App"><a href="#创建App" class="headerlink" title="创建App"></a>创建App</h2><p>跳转到你维护源代码的目录中，并创建你的cordova项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova create hello com.example.hello HelloWorld</span><br></pre></td></tr></table></figure><ul><li>第一个参数是项目目录</li><li>第二个参数是 app 名称 </li><li>第三个参数是项目名称</li></ul><h2 id="添加平台"><a href="#添加平台" class="headerlink" title="添加平台"></a>添加平台</h2><p>所有后续命令都需要在项目目录或者项目目录的任何子目录运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hello</span><br></pre></td></tr></table></figure><p>给你的App添加目标平台。我们将会添加’ios’和’android’平台，并确保他们保存在了config.xml中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cordova platform add ios --save</span><br><span class="line">$ cordova platform add android --save</span><br></pre></td></tr></table></figure><h3 id="检查你当前平台设置状况"><a href="#检查你当前平台设置状况" class="headerlink" title="检查你当前平台设置状况:"></a>检查你当前平台设置状况:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova platform ls</span><br></pre></td></tr></table></figure><h2 id="安装构建先决条件"><a href="#安装构建先决条件" class="headerlink" title="安装构建先决条件"></a>安装构建先决条件</h2><p>要构建和运行App，你需要安装每个你需要平台的SDK。另外，当你使用浏览器开发你可以添加 browser平台，它不需要任何平台SDK。</p><p>检测你是否满足构建平台的要求:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cordova requirements</span><br><span class="line"></span><br><span class="line">Requirements check results <span class="keyword">for</span> android:</span><br><span class="line">Java JDK: installed .</span><br><span class="line">Android SDK: installed</span><br><span class="line">Android target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23</span><br><span class="line">Gradle: installed</span><br><span class="line"></span><br><span class="line">Requirements check results <span class="keyword">for</span> ios:</span><br><span class="line">Apple OS X: not installed</span><br><span class="line">Cordova tooling <span class="keyword">for</span> iOS requires Apple OS X</span><br><span class="line">Error: Some of requirements check failed</span><br></pre></td></tr></table></figure><h2 id="构建App"><a href="#构建App" class="headerlink" title="构建App"></a>构建App</h2><p>默认情况下, <strong>cordova create</strong>生产基于web应用程序的骨架，项目开始页面位于<strong>www/index.html</strong> 文件。任何初始化任务应该在<strong>www/js/index.js</strong>文件中的deviceready事件的事件处理函数中。</p><p>运行下面命令为所有添加的平台构建:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build</span><br></pre></td></tr></table></figure><p>你可以在每次构建中选择限制平台范围 - 这个例子中是’ios’:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build ios</span><br></pre></td></tr></table></figure><h2 id="查看插件列表"><a href="#查看插件列表" class="headerlink" title="查看插件列表"></a>查看插件列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova plugin ls</span><br></pre></td></tr></table></figure><h2 id="查看插件列表-1"><a href="#查看插件列表-1" class="headerlink" title="查看插件列表"></a>查看插件列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova plugin add &lt;插件名称 例子&gt;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova run android</span><br></pre></td></tr></table></figure><h2 id="生成发布版app"><a href="#生成发布版app" class="headerlink" title="生成发布版app"></a>生成发布版app</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build --release</span><br></pre></td></tr></table></figure><h2 id="Adb安装应用程序"><a href="#Adb安装应用程序" class="headerlink" title="Adb安装应用程序"></a>Adb安装应用程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb  install + app路径</span><br></pre></td></tr></table></figure><p>例：</p><blockquote><p>add install /Users/deepera/ws/cordova/client/platforms/android/build/outputs/apk/android-release.apk</p></blockquote><h2 id="查看链接设备"><a href="#查看链接设备" class="headerlink" title="查看链接设备"></a>查看链接设备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      cordova 环境搭建以及基本指令
    
    </summary>
    
      <category term="cordova" scheme="http://yoursite.com/categories/cordova/"/>
    
    
      <category term="cordova" scheme="http://yoursite.com/tags/cordova/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux shell</title>
    <link href="http://yoursite.com/2018/01/23/Linux-shell/"/>
    <id>http://yoursite.com/2018/01/23/Linux-shell/</id>
    <published>2018-01-23T10:57:42.000Z</published>
    <updated>2018-04-30T04:42:37.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf demo.txt</span><br></pre></td></tr></table></figure><p><strong>-rf</strong>:强制删除并且不提醒</p><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> [dirName]</span><br></pre></td></tr></table></figure><p><strong>dirName</strong>：要切换的目标目录。</p><h3 id="查看一个文件"><a href="#查看一个文件" class="headerlink" title="查看一个文件"></a>查看一个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br></pre></td></tr></table></figure><h3 id="触碰一个文件"><a href="#触碰一个文件" class="headerlink" title="触碰一个文件"></a>触碰一个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch demo.txt</span><br></pre></td></tr></table></figure><p><strong>如果没有这个文件则新建</strong></p><h3 id="新建一个文件夹"><a href="#新建一个文件夹" class="headerlink" title="新建一个文件夹"></a>新建一个文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo</span><br></pre></td></tr></table></figure><h2 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h2><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><p><strong>端口号</strong>: -P2222</p><p><strong>username</strong>: root</p><p><strong>IP</strong>: 47.94.238.16</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -P2222 root@47.94.238.16</span><br></pre></td></tr></table></figure><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>-A 　显示所有程序。 </p><p>-e 　此参数的效果和指定”A”参数相同。</p><p>-f 　显示<a href="https://www.baidu.com/s?wd=UID&amp;tn=67012150_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrjb0T1Y1n16krjF9nHn3uhuBuynv0ZwV5fKWUMw85HmLnjDznHRsgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPW6sPjmLPWR1njDsrjRsn1Tz" target="_blank" rel="noopener">UID</a>,PPIP,C与S<a href="https://www.baidu.com/s?wd=TIME&amp;tn=67012150_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrjb0T1Y1n16krjF9nHn3uhuBuynv0ZwV5fKWUMw85HmLnjDznHRsgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPW6sPjmLPWR1njDsrjRsn1Tz" target="_blank" rel="noopener">TIME</a>栏位。 </p><p>grep命令是查找</p><p>中间的|是管道命令</p><p>是指ps命令与grep同时执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep java</span><br></pre></td></tr></table></figure><h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h3><blockquote><p><strong>-9强制杀掉进程</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 java_id</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><blockquote><p><strong>-r</strong> 可以上传文件夹</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -p2222 -r demo.txt root@47.94.238.16:/usr/<span class="built_in">local</span>/tomcat/tomcat_api/webapps</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      linux 命令汇总
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
</feed>
