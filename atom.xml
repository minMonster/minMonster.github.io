<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bling</title>
  
  <subtitle>Monster&#39;s bling</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-14T06:09:07.501Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Monster</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDE-eslint-自动格式化（webstorm、vsCode）</title>
    <link href="http://yoursite.com/2019/10/30/IDE-eslint-%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88webstorm%E3%80%81vsCode%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/30/IDE-eslint-自动格式化（webstorm、vsCode）/</id>
    <published>2019-10-30T08:19:19.000Z</published>
    <updated>2019-11-14T06:09:07.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-VScode配置"><a href="#1-VScode配置" class="headerlink" title="1. VScode配置"></a>1. VScode配置</h1><ol><li><p>安装<code>eslint</code>和<code>vetur</code>插件</p><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/vscode-eslint%E5%AE%89%E8%A3%85.png" alt=""></p></li><li><p><code>command + ，</code>打开配置项，点击编辑器右上角的<code>{}</code>符号</p><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/vscode-%E9%85%8D%E7%BD%AE%E9%A1%B9.png" alt=""></p></li><li><p>追加下列代码</p><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/vscode-%E9%85%8D%E7%BD%AE.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;workbench.startupEditor&quot;: &quot;newUntitledFile&quot;,</span><br><span class="line">    &quot;explorer.confirmDelete&quot;: false,</span><br><span class="line">    &quot;window.zoomLevel&quot;: 2,</span><br><span class="line">    &quot;eslint.autoFixOnSave&quot;: true, //  启用保存时自动修复,默认只支持.js文件</span><br><span class="line">    &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">    &quot;eslint.validate&quot;: [</span><br><span class="line">        &quot;javascript&quot;, //  用eslint的规则检测js文件</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;language&quot;: &quot;vue&quot;, // 检测vue文件</span><br><span class="line">            &quot;autoFix&quot;: true //  为vue文件开启保存自动修复的功能</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;emmet.syntaxProfiles&quot;: &#123;</span><br><span class="line">        &quot;vue-html&quot;: &quot;html&quot;,</span><br><span class="line">        &quot;vue&quot;: &quot;html&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,</span><br><span class="line">    &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,</span><br><span class="line">    &quot;vetur.format.options.tabSize&quot;: 4,</span><br><span class="line">    &quot;vetur.format.options.useTabs&quot;: false,</span><br><span class="line">    &quot;vetur.format.defaultFormatterOptions&quot;: &#123;</span><br><span class="line">        &quot;prettier&quot;: &#123;</span><br><span class="line">            &quot;printWidth&quot;: 200, // No line exceeds 100 characters</span><br><span class="line">            &quot;semi&quot;: true,</span><br><span class="line">            &quot;singleQuote&quot;: true // Prefer double quotes over single quotes</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;prettyhtml&quot;: &#123;</span><br><span class="line">            // &quot;printWidth&quot;: 100, // No line exceeds 100 characters</span><br><span class="line">            &quot;singleQuote&quot;: false // Prefer double quotes over single quotes</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开package.json文件，新增代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@vue/eslint-config-standard&quot;: &quot;^4.0.0&quot;,// Vue中JS的严格语法标准</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,// babel-eslint可以对所有有效的babel代码进行lint处理</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.8.0&quot;,// 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,// vue中template的语法标准</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除node_modules,重新下载：<code>npm i</code></p></li><li>ok！</li></ol><h1 id="2-WebStorem配置"><a href="#2-WebStorem配置" class="headerlink" title="2. WebStorem配置"></a>2. WebStorem配置</h1><ol><li><p>同上述4，5两步，加入依赖，并下载</p></li><li><p><code>command + ,</code>打开配置项</p><ol><li>Languages &amp; Frameworks</li><li>选中Javascript</li><li>选中Code Quality Tools</li><li>选中 Eslint</li><li>右侧界面，勾选Enable，启动eslint检测</li><li>选择Eslint Packages包为本地包（此处可以设置为全局，但是担忧全局的包版本和本地包版本不同，带来一系列问题，这个可以后期迭代，确认设置全局是否没问题）</li></ol></li></ol><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm%E9%85%8D%E7%BD%AEeslint.png" alt=""></p><ol start="3"><li>打开vue，js文件，右键点击<code>Fix ESlint Problems</code>，则代码正常格式化</li></ol><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm-eslint-contextmenu.png" alt=""></p><ol start="4"><li><p>每次需要右键格式化，太麻烦，我们需要自定义一个 webstorm的宏任务，通过<code>ctrl + s</code>自动格式化</p><p><strong>核心原理：录制一段操作，并设定快捷键，之后通过快捷键将此次所有操作执行一遍。</strong></p><ol><li>打开一个.js/.html/.vue文件</li><li>选中webstorm导航Edit选项</li><li>选中Macros选项</li><li>选中Start Macros Recording（关键步骤，主要是录制）</li></ol></li></ol><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm-macros.png" alt=""></p><p>之后所有的操作，都是被WebStorm记录</p><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm-macros-record.png" alt=""></p><p><strong>接下里的操作很关键，请注意：</strong></p><ol><li><p>在内容区域点击右键，找到 <code>Fix ESlint Problems</code>，并点击</p></li><li><p>在<code>ctrl + s</code>保存代码</p></li><li>最后点击上图的<code>停止</code>按钮，并保存自定义名字（此处我设置名称为<strong>save &amp; format</strong>）</li></ol><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm-macros-save-record.png" alt=""></p><ol start="5"><li><code>command + ,</code>打开webstorm配置项<ol><li>选中左侧栏目的 <code>Keymap</code>选项</li><li>在后侧内容区域，输入 save或者format关键字</li><li>选中刚才保存的名字，右击或者双击，选中 <code>Add Keyboard Shortcut</code></li></ol></li></ol><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm-macros-search-modify.png" alt=""></p><p>​    4. 按下<code>ctrl + s</code>，提示冲突覆盖的词语（不展示图了），覆盖即可</p><p><img src="https://junblog.oss-cn-beijing.aliyuncs.com/webstorm-macros-change-keymap-name.png" alt=""></p><p>​    5. OK，找一个vue/js文件测试即可</p><h1 id="3-推荐好用的VS-code插件"><a href="#3-推荐好用的VS-code插件" class="headerlink" title="3. 推荐好用的VS code插件"></a>3. 推荐好用的VS code插件</h1><ol><li><p>Turbo Console Log：快速打印变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + alt + L</span><br></pre></td></tr></table></figure></li><li><p>Gitlens：查看git记录</p></li></ol><h1 id="4-使用技巧"><a href="#4-使用技巧" class="headerlink" title="4. 使用技巧"></a>4. 使用技巧</h1><ol><li>option + command + up/down：光标停留在多行</li></ol>]]></content>
    
    <summary type="html">
    
      IDE-eslint-自动格式化（webstorm、vsCode）
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>启示录-产品</title>
    <link href="http://yoursite.com/2019/07/01/%E3%80%8A%E5%90%AF%E7%A4%BA%E5%BD%95%E3%80%8B%E4%BA%A7%E5%93%81/"/>
    <id>http://yoursite.com/2019/07/01/《启示录》产品/</id>
    <published>2019-06-30T16:36:46.000Z</published>
    <updated>2019-11-14T06:09:07.512Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./《启示录》产品/启示录-产品.jpeg" alt="脑图"></p>]]></content>
    
    <summary type="html">
    
      启示录 思维导图
    
    </summary>
    
      <category term="产品" scheme="http://yoursite.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>启示录-流程篇</title>
    <link href="http://yoursite.com/2019/06/26/%E5%90%AF%E7%A4%BA%E5%BD%95-%E6%B5%81%E7%A8%8B%E7%AF%87/"/>
    <id>http://yoursite.com/2019/06/26/启示录-流程篇/</id>
    <published>2019-06-26T03:15:32.000Z</published>
    <updated>2019-11-14T06:09:07.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./启示录-流程篇/《启示录》--流程.jpeg" alt="脑图"></p>]]></content>
    
    <summary type="html">
    
      启示录 思维导图
    
    </summary>
    
      <category term="产品" scheme="http://yoursite.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>人人都是产品经理</title>
    <link href="http://yoursite.com/2019/06/16/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/16/人人都是产品经理/</id>
    <published>2019-06-16T15:38:15.000Z</published>
    <updated>2019-11-14T06:09:07.516Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./人人都是产品经理/人人都是产品经理-5、6、7新增.png" alt="脑图"></p>]]></content>
    
    <summary type="html">
    
      人人都是产品经理 思维导图
    
    </summary>
    
      <category term="产品" scheme="http://yoursite.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>启示录</title>
    <link href="http://yoursite.com/2019/06/16/%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/16/启示录/</id>
    <published>2019-06-16T15:38:15.000Z</published>
    <updated>2019-11-14T06:09:07.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./启示录/《启示录》.png" alt="脑图"></p>]]></content>
    
    <summary type="html">
    
      启示录 思维导图
    
    </summary>
    
      <category term="产品" scheme="http://yoursite.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="产品" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>docker实战01-概念篇</title>
    <link href="http://yoursite.com/2019/06/10/docker%E5%AE%9E%E6%88%9801-%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
    <id>http://yoursite.com/2019/06/10/docker实战01-概念篇/</id>
    <published>2019-06-10T08:19:19.000Z</published>
    <updated>2019-11-14T06:09:07.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想要弄清楚一件事情或者一个东西到底是什么无外乎是三个问题</p><ul><li>what？什么东西？</li><li>why？为什么这东西能做到？</li><li>how？这东西要如何去使用？</li></ul><p>所以本文以上面三个问题来展开陈述</p><h1 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们知道，软件依赖的环境大致包括：</p><ul><li>操作系统</li><li>配置文件</li><li>代码</li><li>开发工具包</li><li>软件服务器</li></ul><p>Docker作为一个软件集装箱化平台，可以让开发者构建应用程序时，将它与其依赖环境一起打包到一个容器中，然后很容易地发布和应用到任意平台中。</p><p><img src="./docker实战01-概念篇/9a7056bece5fbc063035491ce8481456.jpg" alt="docker-01"></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul><li>Isolation (隔离)</li><li>Standardized (标准化)</li><li>Container (集装箱)</li></ul><p>引用官网一句话</p><p><strong>Package Software into Standardized Units for Development, Shipment and Deployment</strong><br>译文：将软件打包成标准化的单元，用于开发、交付和部署</p><p><strong>引用知乎大佬高赞总结</strong><br>作者：刘允鹏<br>链接：<a href="https://www.zhihu.com/question/28300645/answer/67707287" target="_blank" rel="noopener">https://www.zhihu.com/question/28300645/answer/67707287</a><br>来源：知乎</p><blockquote><p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。</p></blockquote><blockquote><p>1.不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。</p></blockquote><blockquote><p>2.你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。</p></blockquote><blockquote><p>3.在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。</p></blockquote><p><img src="./docker实战01-概念篇/container-what-is-container.png" alt="docker-02"></p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>docker有3大核心：镜像、容器、仓库。</p><p>鲸鱼是操作系统。<br>要交付的应用程序是各种货物，要将各种形状和尺寸不同的货物放到大鲸鱼上，得考虑每件货物怎么安放（应用程序配套的环境），还得考虑货物和货物之间能否重叠起来（应用程序依赖的环境是否会冲突）。<br>现在使用了集装箱（容器）把每件货物都放到集装箱里，这样大鲸鱼可以用同样地方式安放、堆叠集装了，省事省力。<br>即：打包放到鲸鱼上，鲸鱼放到服务器上。也就是“build——ship——run”，这样在自己的电脑上怎么运行，在服务器上也会怎么运行。<br>用</p><p><strong>去仓库把镜像拉到本地，然后用一条命令把镜像运行起来，变成容器。</strong></p><h3 id="镜像-复制的程序-Image"><a href="#镜像-复制的程序-Image" class="headerlink" title="镜像-复制的程序(Image)"></a>镜像-复制的程序(Image)</h3><p><img src="./docker实战01-概念篇/timg.jpeg" alt="docker-03"></p><ul><li><p>定义：<br>类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</p></li><li><p>作用<br>类似于虚拟机的快照，用来创建新的容器。</p></li><li><p>特点<br>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li></ul><h3 id="容器-集装箱-Container"><a href="#容器-集装箱-Container" class="headerlink" title="容器-集装箱(Container)"></a>容器-集装箱(Container)</h3><p>类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</p><ul><li>运行程序的地方</li><li>镜像是静态的，每一层都只是可读的，而容器是动态的，里面运行着我们指定的应用。</li></ul><h3 id="仓库-存放镜像的地方-Repository"><a href="#仓库-存放镜像的地方-Repository" class="headerlink" title="仓库-存放镜像的地方(Repository)"></a>仓库-存放镜像的地方(Repository)</h3><ul><li>类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li></ul><h1 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h1><p><strong>在知乎上看到一个很好的解释</strong><br><img src="./docker实战01-概念篇/20190131193142244.png" alt="docker-04"></p><p>简单来说就是，不同的应用程序所依赖的环境不一样，如果把他们依赖的软件都安装在一个服务器上，不仅需要调试很久，而且可能会有冲突。</p><p>如果想把两个应用程序隔离起来，可以在服务器上创建不同的虚拟机，不同的虚拟机放不同的应用，但是虚拟机的开销比较高。docker作为轻量级的虚拟机，是一个很好的工具。</p><p><img src="./docker实战01-概念篇/20190131155147837.png" alt="docker-05"></p><h2 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h2><ul><li>解决运行环境不一致所导致的问题。这样就不会产生“本地运行没问题，可一到服务器上就不行了”的情况。</li><li>限定最大的cpu使用内存硬盘，这样就起到了隔离的作用，避免产生“一块代码产生死循环，把磁盘占满了，其它程序也挂了”的情况。</li><li>双11时扩展机器用。</li></ul><p><img src="./docker实战01-概念篇/20190131203930409.png" alt="docker-06"></p><p><strong>总结成一句话：docker的标准化让快速扩展，弹性伸缩变得简单</strong></p><h2 id="使用之前和之后"><a href="#使用之前和之后" class="headerlink" title="使用之前和之后"></a>使用之前和之后</h2><p>之前，可以发现，每发布一个程序，都要走一遍以下的流程：</p><p><img src="./docker实战01-概念篇/20190131173509954.png" alt="docker-07"></p><p>之后：</p><p><img src="./docker实战01-概念篇/20190131173524559.png" alt="docker-07"></p><h1 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h1><p>docker安装？<br>1、检查计算机是否符合要求，版本和是否开启了虚拟化之类的。<br>2、去官网下载并安装<br>3、测试是否安装成功<br>这是一篇描述在win10上安装docker的博客：<br><a href="https://blog.csdn.net/hunan961/article/details/79484098" target="_blank" rel="noopener">https://blog.csdn.net/hunan961/article/details/79484098</a></p><h2 id="docker的使用？——hello-world"><a href="#docker的使用？——hello-world" class="headerlink" title="docker的使用？——hello world"></a>docker的使用？——hello world</h2><p>从中央库中拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><p><img src="./docker实战01-概念篇/企业微信截图_671d493e-c48d-4b3c-860c-5c2f838b521a.png" alt="docker-08"></p><p>查询到拉取成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="./docker实战01-概念篇/企业微信截图_35a94c44-9b40-43b7-88bd-6424a284d4c5.png" alt="docker-09"></p><p>运行镜像，查看到结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="./docker实战01-概念篇/企业微信截图_81512df8-df8f-4055-a0e1-281e32a168cb.png" alt="docker-10"></p><p>原理解析</p><p><img src="./docker实战01-概念篇/20190131202811346.png" alt="docker-11"></p><ul><li>docker pull的时候，Docker damemon先在本地仓库中找，如果没有，再去中央仓库中拉取，拉取到本地仓库就好了。</li><li>docker run的时候，也是先在本地仓库中找，如果有，直接放到容器里用。否则，去中央仓库中拉取。</li></ul><p><strong>注：本文参考于 <a href="https://blog.csdn.net/qsbbl/article/details/86715741" target="_blank" rel="noopener">https://blog.csdn.net/qsbbl/article/details/86715741</a></strong></p>]]></content>
    
    <summary type="html">
    
      docker实战01-概念篇
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>web高性能动画</title>
    <link href="http://yoursite.com/2019/05/23/web%E9%AB%98%E6%80%A7%E8%83%BD%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/05/23/web高性能动画/</id>
    <published>2019-05-23T10:36:30.000Z</published>
    <updated>2019-11-14T06:09:07.511Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./web高性能动画/web高性能动画.png" alt="脑图"></p>]]></content>
    
    <summary type="html">
    
      web高性能动画
    
    </summary>
    
      <category term="Css" scheme="http://yoursite.com/categories/Css/"/>
    
    
      <category term="Css" scheme="http://yoursite.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>你为什么卸载今日头条和抖音？（转载自知乎）</title>
    <link href="http://yoursite.com/2019/05/23/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%B8%E8%BD%BD%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%92%8C%E6%8A%96%E9%9F%B3%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/05/23/你为什么卸载今日头条和抖音？/</id>
    <published>2019-05-23T10:18:17.000Z</published>
    <updated>2019-11-14T06:09:07.580Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/316017797/answer/678413996" target="_blank" rel="noopener">原文链接</a><br>李尚龙说了一句脍炙人口的话：</p><p><strong>“在大城市里，搞废一个人的方式特别简单。给你一个安静狭小的空间，给你一根网线，最好再加一个外卖电话。好了，你开始废了。”</strong></p><p>绝不危言耸听。</p><p>一个人待在不用思考的舒适区里，累了，点一顿外卖，困了，来一盘游戏，闷了，刷一波抖音。不但不寂寞，反而更有安全感。</p><p>过了一段时间以后，感官逐渐变得钝化，眼界也日益局限，再也不愿抬头去看向手机外的世界，不想回到令人畏缩的现实。</p><p>这就是重复感给你的毒药——重复让人麻醉，只有变化叫人惊醒。</p><p>如果你找不到这个变化的出口，你可能一辈子，都会在一边刷抖音一边埋怨没时间，一边熬着夜一边害怕着猝死的世界里，彷徨、徘徊、痛不欲生。</p><p>抖音、快手这种算法推荐的声色娱乐App，<strong>最大的特点是无声无息地消耗你的心智。</strong></p><p>难怪，《娱乐至死》中有一句经典的谶语：</p><ul><li>“毁掉我们的不是我们所憎恨的东西，而恰恰是我们所热爱的东西。”</li></ul><p><strong>推荐算法是最剧毒的麻醉剂</strong></p><p>现在这个时代，已经彻底沦为“有机时代”。</p><p><strong>手机成了我们的一个器官。</strong></p><p>被动地接受着手机的推送成了一种时尚——不用思考，不用烧脑，看声像，看动图。</p><p>但事实上这个 <strong>“自动推送”</strong> 的算法的黑洞有多深呢——</p><ul><li><p>算法一手抓内容。图文、视频、小视频、问答、微头条，每种内容有自己的特征；</p></li><li><p>另一只手抓用户。兴趣、职业、年龄、性别、机型……然后刻画出的你的各种隐藏兴趣；</p></li><li><p>三抓环境特征。不同的时间、地点、场景(工作/通勤/旅游等)，对应用户不同的兴趣点。</p></li></ul><p>听上去好像很复杂。复杂就对了，你不懂就对了。</p><p><strong>因为它掌握了大数据，大数据剥光了你。</strong></p><p>这种大数据下的世界，你只能接触到所有人都爱上的东西，</p><ul><li><p>比如“震惊！”、“刚刚！”、“定了！”</p></li><li><p>比如变脸、手势舞、海草海草……</p></li></ul><p><strong>视觉冲击、声乐冲击刺激着你的神经。</strong></p><p>你兴奋，你痛快，你的多巴胺上升到极值；</p><p>你也麻痹，你也顺从，你再也不会思考了。</p><p>想到这里，我不自觉地握了握手中的手机，想起了刘震云说的一句话：</p><ul><li>“现在是哪儿还有净土呢，是一机在手，在劫难逃。”</li></ul><p>夸张一点地说，在你用抖音连上网络那一刻，<strong>你别再指望时间属于你。甚至，你也不再能指望，你的心智属于你，你的爱好属于你。</strong></p><p><strong>你已经被这个App所控制。</strong></p><p><strong>为什么抖音会让我们上瘾？</strong></p><p>心理学博士亚当 · 阿尔特写的《欲罢不能：刷屏时代如何摆脱行为上瘾》一书中，列举了六项行为上瘾的构成要素，分别是：</p><ul><li><p>诱人的目标</p></li><li><p>无法抵挡且无法预知的积极反馈</p></li><li><p>渐进改善的感觉</p></li><li><p>越来越困难的任务</p></li><li><p>需要解决却暂未解决的紧张感</p></li><li><p>强大的社会联系</p></li></ul><p>以上这些，抖音一键全包。</p><p><strong>首先，无法预知的下一页</strong></p><p>和动漫游戏一模一样，你永远不会知道抖音刷一下，下一个画面是什么，这就是一种“无法预知的积极反馈”。</p><p>它就像吊着一根红萝卜引诱兔子，它永远追不上，又永远痴迷。</p><p>特么太刺激了，无法预料的事情，就是一颗诱人的巧克力。</p><p><strong>其次，超级便利的互动</strong></p><p>更让人无可抵挡的是，点赞这个小心心。点一下太容易了，双击666，“即时就反馈”。</p><p>便利的互动让人无法拒绝。</p><p><strong>第三，高音重复音乐反复播</strong></p><p>不得不说，抖音的音乐全是洗脑式的“神曲”，朗朗上口，娇萌可爱，不用1秒你就被节奏带进去了。</p><p>无需搜索，不用思考，音乐的节奏让人进入半催眠状态。有某一刻你也许怀疑，自己到底身在何方。</p><p>1979年，精神病学家科奈利乌斯·埃克特（Cornelius Eckert）将这种现象命名为 <strong>“耳朵虫”</strong>（earworm）现象。它指，</p><ul><li>一段长度为20秒左右的音乐在当事人毫无意识的情况下，突然在脑内反复循环，可以在人的大脑里面持续时间通常为数小时至数天不等。</li></ul><p>科学家进一步的研究表明，三类人最容易被 <strong>“耳朵虫”</strong> 找上门：<strong>神经官能症患者、精神压力较大的人、处于极度疲劳状态的人。</strong></p><p>好吧，我知道，说的就是你。</p><p>你就是那个在“耳朵虫”的引诱下越走越远，直到手机低电量的提示音像个闹钟一样提示你不能再玩的傻白甜。</p><p><strong>当我假装卸载了抖音…</strong></p><p><strong>颜之推说：“天下事以难而废者十之一，以惰而废者十之九。”</strong></p><p>是的，我就是那个以惰而废的人。</p><p>我曾经“假装”卸载了抖音，决心决意每天都不再碰它。</p><p>然而三天之后，我又以“研究新媒体动态”为借口，无法自拔地沉迷进去。</p><p>一刷三小时，稿子也没法写了，深深陷入了 <strong>“假装不理他”—“还是会想他”—“真的离不开他”—“从此恨透了他”—“又假装不理他”的死循环。</strong></p><p>相比之下，有一个普通的工地妇女——马慧娟则比我牛多了。</p><p>她和很多很多的你我一样，时时刻刻都在看手机，工作时看，吃饭时看，睡觉也看。</p><p>乍看，似乎应该是抖音迷、快手王、今日头条之星。可谁能猜到，她其实是在利用手机在写作。</p><p>家境贫穷的她没能念完初中，婚后才拥有第一部手机。拿到手机后的几年里，她没有在抖音快手这种十八线城市必备品里沉迷，反而一直坚持在手机上撰写自己的文章，最后洋洋洒洒写下一百多万字，出版了散文集《溪风絮语》。</p><p>归根结底，<strong>手机吸引懒人，培养懒人，摧毁的也是懒人。</strong></p><p><strong>所以，重要的不是你卸不卸载抖音。</strong></p><p><strong>而是你拿着手机那一刻，心中有志，眼里有事。</strong></p>]]></content>
    
    <summary type="html">
    
      你为什么卸载今日头条和抖音？
    
    </summary>
    
      <category term="文章分享" scheme="http://yoursite.com/categories/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="文章分享" scheme="http://yoursite.com/tags/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器（Centos）部署 node 服务，问题记录</title>
    <link href="http://yoursite.com/2019/05/23/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Centos%EF%BC%89%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/23/阿里云服务器（Centos）问题记录/</id>
    <published>2019-05-23T03:13:46.000Z</published>
    <updated>2019-11-14T06:09:07.597Z</updated>
    
    <content type="html"><![CDATA[<p>最近手里有一个官网展示项目，本地开发还算顺利，阿里云服务器部署遇到了一些问题</p><h3 id="用node启动server后，发现服务器不稳定，经常crash。我是用ssh远程登录的，ssh远程通道中断，或者Ctrl-C-都会使nodejs-server崩溃掉。"><a href="#用node启动server后，发现服务器不稳定，经常crash。我是用ssh远程登录的，ssh远程通道中断，或者Ctrl-C-都会使nodejs-server崩溃掉。" class="headerlink" title="用node启动server后，发现服务器不稳定，经常crash。我是用ssh远程登录的，ssh远程通道中断，或者Ctrl+C,都会使nodejs server崩溃掉。"></a>用node启动server后，发现服务器不稳定，经常crash。我是用ssh远程登录的，ssh远程通道中断，或者Ctrl+C,都会使nodejs server崩溃掉。</h3><p>使用 nohup 来启动项目（不是最优解决方案）<br>用途：不挂断地运行命令（也就是后台运营node程序）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup yarn start &amp;</span><br></pre></td></tr></table></figure></p><h4 id="使用-nohup-启动服务解决了-断开-shh-服务中断这个问题"><a href="#使用-nohup-启动服务解决了-断开-shh-服务中断这个问题" class="headerlink" title="使用 nohup 启动服务解决了 断开 shh 服务中断这个问题"></a>使用 nohup 启动服务解决了 断开 shh 服务中断这个问题</h4><p>但是不能保证 node 服务因为意外的报错中断服务 下文给出了解决方案</p><h3 id="node-是单线程阻塞-io-，意味着有可能服务遇到报错直接停止服务器"><a href="#node-是单线程阻塞-io-，意味着有可能服务遇到报错直接停止服务器" class="headerlink" title="node 是单线程阻塞 io ，意味着有可能服务遇到报错直接停止服务器"></a>node 是单线程阻塞 io ，意味着有可能服务遇到报错直接停止服务器</h3><p>单线程的某处产生了“未处理的”异常确实会导致整个Node.JS的崩溃退出，来看个例子, 这里有一个node-error.js的文件： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(＇http＇);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里有个错误，params 是 undefined</span></span><br><span class="line">  <span class="keyword">var</span> ok = req.params.ok;</span><br><span class="line"></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;＇Content-Type＇: ＇text/plain＇&#125;);</span><br><span class="line">  res.end(＇Hello World</span><br><span class="line">＇);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, ＇<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>＇);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(＇Server running at http:<span class="comment">//127.0.0.1:8080/＇);</span></span><br></pre></td></tr></table></figure><p>启动服务，并在地址栏测试一下发现 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a>  不出所料，node崩溃了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ node node-error</span><br><span class="line">Server running at http://127.0.0.1:8080/</span><br><span class="line"></span><br><span class="line">c:githubscript</span><br><span class="line">ode-error.js:5</span><br><span class="line">  var ok = req.params.ok;</span><br><span class="line">                     ^</span><br><span class="line">TypeError: Cannot <span class="built_in">read</span> property ＇ok＇ of undefined</span><br><span class="line">    at Server.&lt;anonymous&gt; (c:githubscript</span><br><span class="line">ode-error.js:5:22)</span><br><span class="line">    at Server.EventEmitter.emit (events.js:98:17)</span><br><span class="line">    at HTTPParser.parser.onIncoming (http.js:2108:12)</span><br><span class="line">    at HTTPParser.parserOnHeadersComplete [as onHeadersComplete] (http.js:121:23)</span><br><span class="line">    at Socket.socket.ondata (http.js:1966:22)</span><br><span class="line">    at TCP.onread (net.js:525:27)</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/xiunai78/article/details/40378965/" target="_blank" rel="noopener">原文</a>有写怎么在逻辑层处理报错<br>这种情况当然不是我们愿意看到的，怎么保持服务的稳定性呢？</p><h4 id="使用-pm2-来守护进程-保证服务-不会因为某一个错误，导致全线崩溃"><a href="#使用-pm2-来守护进程-保证服务-不会因为某一个错误，导致全线崩溃" class="headerlink" title="使用 pm2 来守护进程 保证服务 不会因为某一个错误，导致全线崩溃"></a>使用 pm2 来守护进程 保证服务 不会因为某一个错误，导致全线崩溃</h4><p>pm2 简介</p><ul><li>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。<br>pm2 安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>入门教程<br>使用我们当前的 koa2 项目来举例。一般我们都是使用 yarn start 来启动应用 实际上 是使用 node bin/www 来启动项目<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "start": "node bin/www",</span><br><span class="line">   "dev": "./node_modules/.bin/nodemon bin/www",</span><br><span class="line">   "prd": "pm2 start bin/www",</span><br><span class="line">   "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意，这里用了–watch参数，意味着当你的koa2应用代码发生变化时，pm2会帮你重启服务，多贴心。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ./bin/www --watch</span><br></pre></td></tr></table></figure>入门太简单了，没什么好讲的。直接上<a href="http://pm2.keymetrics.io/docs/usage/quick-start" target="_blank" rel="noopener">官方文档</a></li></ul><p>详细使用教程 参考 <a href="https://blog.csdn.net/maquealone/article/details/79550120" target="_blank" rel="noopener">PM2实用入门指南</a></p><p>我们服务启动了，我们通过 nginx 反向代理 将服务代理到 9010 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  9010;</span><br><span class="line">        server_name 47.***.***.72;</span><br><span class="line">    root 47.***.***.72;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:3000;</span><br><span class="line">                proxy_http_version 1.1;</span><br><span class="line">                proxy_set_header   Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">                proxy_set_header   Connection keep-alive;</span><br><span class="line">                proxy_set_header   Host <span class="variable">$http_host</span>;</span><br><span class="line">                proxy_cache_bypass <span class="variable">$http_upgrade</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="服务启动了但是通过-ip-端口号不能访问"><a href="#服务启动了但是通过-ip-端口号不能访问" class="headerlink" title="服务启动了但是通过 ip + 端口号不能访问"></a>服务启动了但是通过 ip + 端口号不能访问</h3><p>但是我发现 通过服务器 ip 端口号访问 并不通 why？？？？</p><p>思考了一下列举出了以下可能的问题</p><h4 id="首先验证服务是否是正常的"><a href="#首先验证服务是否是正常的" class="headerlink" title="首先验证服务是否是正常的"></a>首先验证服务是否是正常的</h4><p>我们通过 ssh 进入服务器<br>然后查看 进程是否还在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">┌──────┬────┬──────┬─────────┬────┬──────┬───────────┐</span><br><span class="line">│ Name │ id │ mode │ status  │ ↺  │ cpu  │ memory    │</span><br><span class="line">├──────┼────┼──────┼─────────┼────┼──────┼───────────┤</span><br><span class="line">│ app  │ 1  │ fork │ stopped │ 0  │ 0%   │ 0 B       │</span><br><span class="line">│ node │ 2  │ fork │ online  │ 0  │ 0%   │ 17.3 MB   │</span><br><span class="line">│ www  │ 3  │ fork │ online  │ 0  │ 0.2% │ 80.4 MB   │</span><br><span class="line">│ yarn │ 0  │ fork │ stopped │ 75 │ 0%   │ 0 B       │</span><br><span class="line">└──────┴────┴──────┴─────────┴────┴──────┴───────────┘</span><br></pre></td></tr></table></figure><p>我们看到服务正在正常的跑着</p><h4 id="端口号是否是通的"><a href="#端口号是否是通的" class="headerlink" title="端口号是否是通的"></a>端口号是否是通的</h4><p>查看 80 默认端口是否通</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name 47.***.***.72;</span><br><span class="line">    root 47.***.***.72;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:3000;</span><br><span class="line">                proxy_http_version 1.1;</span><br><span class="line">                proxy_set_header   Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">                proxy_set_header   Connection keep-alive;</span><br><span class="line">                proxy_set_header   Host <span class="variable">$http_host</span>;</span><br><span class="line">                proxy_cache_bypass <span class="variable">$http_upgrade</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>将 node 服务代理到 80端口</p><p>发现通过 ip 直接访问是通的</p><p>这时候就可以得出结论</p><ul><li>服务是没有问题的</li><li>9010 端口可能不通</li></ul><p>但是为什么80端口是通的9010是不通的？<br>通过百度大法，以及多方打听列举处两个有可能的点</p><ul><li><p>阿里云安全组端口权限</p></li><li><p>centos 防火墙端口是否开启</p></li></ul><h3 id="Centos-防火墙-开放端口"><a href="#Centos-防火墙-开放端口" class="headerlink" title="Centos 防火墙 开放端口"></a>Centos 防火墙 开放端口</h3><p>使用 systemd 来管理 firewalld<br>systemd 是 Linux 下的一款系统和服务管理器，兼容 SysV 和 LSB 的启动脚本。systemd 的特性有：支持并行化任务；同一时候採用 socket 式与 D-Bus 总线式激活服务；按需启动守护进程（daemon）。利用 Linux 的 cgroups 监视进程；支持快照和系统恢复。维护挂载点和自己主动挂载点。各服务间基于依赖关系进行精密控制。<br>1、firewalld的基本使用<br>启动： systemctl start firewalld<br>关闭： systemctl stop firewalld<br>查看状态： systemctl status firewalld<br>开机禁用  ： systemctl disable firewalld<br>开机启用  ： systemctl enable firewalld</p><p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。<br>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctl is-enabled firewalld.service<br>查看已启动的服务列表：systemctl list-unit-files|grep enabled<br>查看启动失败的服务列表：systemctl –failed</p><p>3.配置firewalld-cmd</p><p>查看版本： firewall-cmd –version<br>查看帮助： firewall-cmd –help<br>显示状态： firewall-cmd –state<br>查看所有打开的端口： firewall-cmd –zone=public –list-ports<br>更新防火墙规则： firewall-cmd –reload<br>查看区域信息:  firewall-cmd –get-active-zones<br>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0<br>拒绝所有包：firewall-cmd –panic-on<br>取消拒绝状态： firewall-cmd –panic-off<br>查看是否拒绝： firewall-cmd –query-panic</p><p>那怎么开启一个端口呢<br>添加<br>firewall-cmd –zone=public –add-port=80/tcp –permanent    （–permanent永久生效，没有此参数重启后失效）<br>重新载入<br>firewall-cmd –reload<br>查看<br>firewall-cmd –zone= public –query-port=80/tcp<br>删除<br>firewall-cmd –zone= public –remove-port=80/tcp –permanent</p><h3 id="阿里云开放安全组"><a href="#阿里云开放安全组" class="headerlink" title="阿里云开放安全组"></a>阿里云开放安全组</h3><p>废话少说直接上阿里云文档 <a href="https://helpcdn.aliyun.com/document_detail/25471.html" target="_blank" rel="noopener">添加安全组规则</a></p>]]></content>
    
    <summary type="html">
    
      阿里云服务器（Centos）部署 node 服务，问题记录
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="问题总结" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="http://yoursite.com/2019/01/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/01/13/面向对象/</id>
    <published>2019-01-13T14:38:06.000Z</published>
    <updated>2019-01-13T14:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果要我总结一下学习前端以来我遇到了哪些瓶颈，那么面向对象一定是第一个毫不犹豫想到的。尽管我现在对于面向对象有了一些的了解，但是当初的那种似懂非懂的痛苦，依然历历在目。</p><p>为了帮助大家能够更加直观的学习和了解面向对象，我会用尽量简单易懂的描述来展示面向对象的相关知识。并且也准备了一些实用的例子帮助大家更加快速的掌握面向对象的真谛。</p><ul><li><p>jQuery的面向对象实现</p></li><li><p>封装拖拽</p></li><li><p>简易版运动框架封装</p></li></ul><p>这可能会花一点时间，但是却值得期待。所以如果有兴趣的朋友可以来简书和公众号关注我。</p><p>而这篇文章主要来聊一聊关于面向对象的一些重要的基本功。</p><h5 id="一、对象的定义"><a href="#一、对象的定义" class="headerlink" title="一、对象的定义"></a>一、对象的定义</h5><p>在ECMAScript-262中，对象被定义为<strong>“无序属性的集合，其属性可以包含基本值，对象或者函数”</strong>。</p><p>也就是说，在JavaScript中，对象无非就是由一些列无序的<code>key-value</code>对组成。其中value可以是基本值，对象或者函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这里的person就是一个对象</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    getName: function() &#123;&#125;,</span><br><span class="line">    parent: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h6><p>我们可以通过new的方式创建一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br></pre></td></tr></table></figure><p>也可以通过对象字面量的形式创建一个简单的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>当我们想要给我们创建的简单对象添加方法时，可以这样表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 可以这样</span><br><span class="line">var person = &#123;&#125;;</span><br><span class="line">person.name = &quot;TOM&quot;;</span><br><span class="line">person.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以这样</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;TOM&quot;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="访问对象的属性和方法"><a href="#访问对象的属性和方法" class="headerlink" title="访问对象的属性和方法"></a>访问对象的属性和方法</h6><p>假如我们有一个简单的对象如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;TOM&apos;,</span><br><span class="line">    age: &apos;20&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要访问他的name属性时，可以用如下两种方式访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.name</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">person[&apos;name&apos;]</span><br></pre></td></tr></table></figure><p>如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;name&apos;, &apos;age&apos;].forEach(function(item) &#123;</span><br><span class="line">    console.log(person[item]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。</p></blockquote><h5 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h5><p>使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求。就以person对象为例。假如我们在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var perTom = &#123;</span><br><span class="line">    name: &apos;TOM&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var perJake = &#123;</span><br><span class="line">    name: &apos;Jake&apos;,</span><br><span class="line">    age: 22,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然这并不是合理的方式，当相似对象太多时，大家都会崩溃掉。</p><p>我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var createPerson = function(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 声明一个中间对象，该对象就是工厂模式的模子</span><br><span class="line">    var o = new Object();</span><br><span class="line"></span><br><span class="line">    // 依次添加我们需要的属性与方法</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.getName = function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建两个实例</span><br><span class="line">var perTom = createPerson(&apos;TOM&apos;, 20);</span><br><span class="line">var PerJake = createPerson(&apos;Jake&apos;, 22);</span><br></pre></td></tr></table></figure><p>相信上面的代码并不难理解，也不用把工厂模式看得太过高大上。很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦，需要我们注意。</p><p>第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。使用instanceof可以识别对象的类型，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var foo = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj instanceof Object);  // true</span><br><span class="line">console.log(foo instanceof Function); // true</span><br></pre></td></tr></table></figure><p>因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。</p><h5 id="三、构造函数"><a href="#三、构造函数" class="headerlink" title="三、构造函数"></a>三、构造函数</h5><p>在JavaScript中，new关键字可以让一个函数变得与众不同。通过下面的例子，我们来一探new关键字的神奇之处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo();  // window</span><br><span class="line">new demo();  // demo</span><br></pre></td></tr></table></figure><p>为了能够直观的感受他们不同，建议大家动手实践观察一下。很显然，使用new之后，函数内部发生了一些变化，让this指向改变。那么new关键字到底做了什么事情呢。嗯，其实我之前在文章里用文字大概表达了一下new到底干了什么，但是一些同学好奇心很足，总期望用代码实现一下，我就大概以我的理解来表达一下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span><br><span class="line">var Person = function(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将构造函数以参数形式传入</span><br><span class="line">function New(func) &#123;</span><br><span class="line"></span><br><span class="line">    // 声明一个中间对象，该对象为最终返回的实例</span><br><span class="line">    var res = &#123;&#125;;</span><br><span class="line">    if (func.prototype !== null) &#123;</span><br><span class="line"></span><br><span class="line">        // 将实例的原型指向构造函数的原型</span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象</span><br><span class="line">    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));</span><br><span class="line"></span><br><span class="line">    // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span><br><span class="line">    if ((typeof ret === &quot;object&quot; || typeof ret === &quot;function&quot;) &amp;&amp; ret !== null) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span><br><span class="line">var p1 = New(Person, &apos;tom&apos;, 20);</span><br><span class="line">console.log(p1.getName());</span><br><span class="line"></span><br><span class="line">// 当然，这里也可以判断出实例的类型了</span><br><span class="line">console.log(p1 instanceof Person); // true</span><br></pre></td></tr></table></figure><blockquote><p>JavaScript内部再通过其他的一些特殊处理，将<code>var p1 = New(Person, &#39;tom&#39;, 20);</code> 等效于<code>var p1 = new Person(&#39;tom&#39;, 20);</code>。就是我们认识的new关键字了。具体怎么处理的，我也不知道，别刨根问底了，一直回答下去太难 - -！</p></blockquote><p>老实讲，你可能很难在其他地方看到有如此明确的告诉你new关键字到底对构造函数干了什么的文章了。理解了这段代码，你对JavaScript的理解又比别人深刻了一分，所以，一本正经厚颜无耻求个赞可好？</p><p>当然，很多朋友由于对于前面几篇文章的知识理解不够到位，会对new的实现表示非常困惑。但是老实讲，如果你读了我的前面几篇文章，一定会对这里new的实现有似曾相识的感觉。而且我这里已经尽力做了详细的注解，剩下的只能靠你自己了。</p><p>但是只要你花点时间，理解了他的原理，那么困扰了无数人的构造函数中this到底指向谁就变得非常简单了。</p><p>所以，为了能够判断实例与对象的关系，我们就使用构造函数来搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Ness&apos;, 20);</span><br><span class="line">console.log(p1.getName());  // Ness</span><br><span class="line"></span><br><span class="line">console.log(p1 instanceof Person); // true</span><br></pre></td></tr></table></figure><p>关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。</p><ul><li>与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数；</li><li>new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程：<ol><li>声明一个中间对象；</li><li>将该中间对象的原型指向构造函数的原型；</li><li>将构造函数的this，指向该中间对象；</li><li>返回该中间对象，即返回实例对象。</li></ol></li></ul><h5 id="四、原型"><a href="#四、原型" class="headerlink" title="四、原型"></a>四、原型</h5><p>虽然构造函数解决了判断实例类型的问题，但是，说到底，还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说，当我们声明了100个person对象，那么就有100个getName方法被重新生成。</p><p>这里的每一个getName方法实现的功能其实是一模一样的，但是由于分别属于不同的实例，就不得不一直不停的为getName分配空间。这就是工厂模式存在的第二个麻烦。</p><p>显然这是不合理的。我们期望的是，既然都是实现同一个功能，那么能不能就让每一个实例对象都访问同一个方法？</p><p>当然能，这就是原型对象要帮我们解决的问题了。</p><p>我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是我们这里说的原型。</p><p>当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个<code>__proto__</code>属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过<code>__proto__</code>访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。</p><p>我们通过一个简单的例子与图示，来了解构造函数，实例与原型三者之间的关系。</p><blockquote><p>由于每个函数都可以是构造函数，每个对象都可以是原型对象，因此如果在理解原型之初就想的太多太复杂的话，反而会阻碍你的理解，这里我们要学会先简化它们。就单纯的剖析这三者的关系。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过prototye属性，将方法挂载到原型对象上</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;tim&apos;, 10);</span><br><span class="line">var p2 = new Person(&apos;jak&apos;, 22);</span><br><span class="line">console.log(p1.getName === p2.getName); // true</span><br></pre></td></tr></table></figure><p><img src="//upload-images.jianshu.io/upload_images/599584-2fc7dad23d112791.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p><p>通过图示我们可以看出，构造函数的prototype与所有实例对象的<code>__proto__</code>都指向原型对象。而原型对象的constructor指向构造函数。</p><p>除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。</p><p><strong>当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        console.log(&apos;this is constructor.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;tim&apos;, 10);</span><br><span class="line"></span><br><span class="line">p1.getName(); // this is constructor.</span><br></pre></td></tr></table></figure><p>在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。</p><p>我们还可以通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;tim&apos;, 10);</span><br><span class="line"></span><br><span class="line">console.log(&apos;name&apos; in p1); // true</span><br></pre></td></tr></table></figure><p>in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isMobile = &apos;ontouchstart&apos; in document;</span><br><span class="line"></span><br><span class="line">// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式</span><br></pre></td></tr></table></figure><p><strong> 更简单的原型写法 </strong></p><p>根据前面例子的写法，如果我们要在原型上添加更多的方法，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function() &#123;&#125;</span><br><span class="line">Person.prototype.getAge = function() &#123;&#125;</span><br><span class="line">Person.prototype.sayHello = function() &#123;&#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>除此之外，我还可以使用更为简单的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    getName: function() &#123;&#125;,</span><br><span class="line">    getAge: function() &#123;&#125;,</span><br><span class="line">    sayHello: function() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。<code>Person.prototype = {}</code>实际上是重新创建了一个<code>{}</code>对象并赋值给Person.prototype，这里的<code>{}</code>并不是最初的那个原型对象。因此它里面并不包含<code>constructor</code>属性。为了保证正确性，我们必须在新创建的<code>{}</code>对象中显示的设置<code>constructor</code>的指向。即上面的<code>constructor: Person</code>。</p><h5 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h5><p>原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。因此理解了原型，那么原型链并不是一个多么复杂的概念。</p><p>我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？</p><p>先随意声明一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以用如下的图来表示这个函数的原型链。</p><p><img src="//upload-images.jianshu.io/upload_images/599584-f4ca22c5db668eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p><p>其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。</p><p>基于原型链的特性，我们可以很轻松的实现<strong>继承</strong>。</p><h5 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h5><p>我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略。</p><p>我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数的继承</span><br><span class="line">function cPerson(name, age, job) &#123;</span><br><span class="line">    Person.call(this, name, age);</span><br><span class="line">    this.job = job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 继承原型</span><br><span class="line">cPerson.prototype = new Person(name, age);</span><br><span class="line"></span><br><span class="line">// 添加更多方法</span><br><span class="line">cPerson.prototype.getLive = function() &#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="//upload-images.jianshu.io/upload_images/599584-c77eb714f66b8185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/927/format/webp" alt="image"></p><p>当然关于继承还有更好的方式。</p><h5 id="七、更好的继承"><a href="#七、更好的继承" class="headerlink" title="七、更好的继承"></a>七、更好的继承</h5><p>假设原型链的终点<code>Object.prototype</code>为原型链的E(end)端，原型链的起点为S(start)端。</p><p>通过前面原型链的学习我们知道，处于S端的对象，可以通过S -&gt; E的单向查找，访问到原型链上的所有方法与属性。因此这给继承提供了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。因此想要实现继承，是一件非常简单的事情。</p><p>因为封装一个对象由构造函数与原型共同组成，因此继承也会分别有构造函数的继承与原型的继承。</p><p>假设我们已经封装好了一个父类对象Person。如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = function() &#123;</span><br><span class="line">    return this.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的继承比较简单，我们可以借助call/apply来实现。假设我们要通过继承封装一个Student的子类对象。那么构造函数可以如下实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Student = function(name, age, grade) &#123;</span><br><span class="line">    // 通过call方法还原Person构造函数中的所有处理逻辑</span><br><span class="line">    Student.call(Person, name, age);</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">var Student = function(name, age, grade) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型的继承则稍微需要一点思考。首先我们应该考虑，如何将子类对象的原型加入到原型链中？我们只需要让子类对象的原型，成为父类对象的一个实例，然后通过<code>__proto__</code>就可以访问父类对象的原型。这样就继承了父类原型中的方法与属性了。</p><p>因此我们可以先封装一个方法，该方法根据父类对象的原型创建一个实例，该实例将会作为子类对象的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function create(proto, options) &#123;</span><br><span class="line">    // 创建一个空对象</span><br><span class="line">    var tmp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 让这个新的空对象成为父类对象的实例</span><br><span class="line">    tmp.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">    // 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型</span><br><span class="line">    Object.defineProperties(tmp, options);</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单封装了<code>create</code>对象之后，我们就可以使用该方法来实现原型的继承了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">    // 不要忘了重新指定构造函数</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: function() &#123;</span><br><span class="line">            return this.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么我们来验证一下我们这里实现的继承是否正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Student(&apos;ming&apos;, 22, 5);</span><br><span class="line"></span><br><span class="line">console.log(s1.getName());  // ming</span><br><span class="line">console.log(s1.getAge());   // 22</span><br><span class="line">console.log(s1.getGrade()); // 5</span><br></pre></td></tr></table></figure><p>全部都能正常访问，没问题。在ECMAScript5中直接提供了一个<code>Object.create</code>方法来完成我们上面自己封装的<code>create</code>的功能。因此我们可以直接使用<code>Object.create</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">    // 不要忘了重新指定构造函数</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: function() &#123;</span><br><span class="line">            return this.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = function() &#123;</span><br><span class="line">    return this.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, grade) &#123;</span><br><span class="line">    // 构造函数继承</span><br><span class="line">    Person.call(this, name, age);</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原型继承</span><br><span class="line">Student.prototype = Object.create(Person.prototype, &#123;</span><br><span class="line">    // 不要忘了重新指定构造函数</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: function() &#123;</span><br><span class="line">            return this.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var s1 = new Student(&apos;ming&apos;, 22, 5);</span><br><span class="line"></span><br><span class="line">console.log(s1.getName());  // ming</span><br><span class="line">console.log(s1.getAge());   // 22</span><br><span class="line">console.log(s1.getGrade()); // 5</span><br></pre></td></tr></table></figure><h5 id="八、属性类型"><a href="#八、属性类型" class="headerlink" title="八、属性类型"></a>八、属性类型</h5><p>在上面的继承实现中，使用了一个大家可能不太熟悉的方法<code>defineProperties</code>。并且在定义<code>getGrade</code>时使用了一个很奇怪的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getGrade: &#123;</span><br><span class="line">    value: function() &#123;</span><br><span class="line">        return this.grade</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实是对象中的属性类型。在我们平常的使用中，给对象添加一个属性时，直接使用<code>object.param</code>的方式就可以了，或者直接在对象中挂载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;TOM&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ECMAScript5中，对每个属性都添加了几个属性类型，来描述这些属性的特点。他们分别是</p><ul><li><strong><code>configurable</code></strong>: 表示该属性是否能被delete删除。当其值为false时，其他的特性也不能被改变。默认值为true</li><li><strong><code>enumerable</code></strong>: 是否能枚举。也就是是否能被for-in遍历。默认值为true</li><li><strong><code>writable</code></strong>: 是否能修改值。默认为true</li><li><strong><code>value</code></strong>: 该属性的具体值是多少。默认为undefined</li><li><strong><code>get</code></strong>: 当我们通过<code>person.name</code>访问name的值时，get将被调用。该方法可以自定义返回的具体值时多少。get默认值为undefined</li><li><strong><code>set</code></strong>: 当我们通过<code>person.name = &#39;Jake&#39;</code>设置name的值时，set方法将被调用。该方法可以自定义设置值的具体方式。set默认值为undefined</li></ul><blockquote><p>需要注意的是，不能同时设置value、writable 与 get、set的值。</p></blockquote><p>我们可以通过<code>Object.defineProperty</code>方法来修改这些属性类型。</p><p>下面我们用一些简单的例子来演示一下这些属性类型的具体表现。</p><p><strong>configurable</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 用普通的方式给person对象添加一个name属性，值为TOM</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;TOM&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用delete删除该属性</span><br><span class="line">delete person.name;  // 返回true 表示删除成功</span><br><span class="line"></span><br><span class="line">// 通过Object.defineProperty重新添加name属性</span><br><span class="line">// 并设置name的属性类型的configurable为false，表示不能再用delete删除</span><br><span class="line">Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">    configurable: false,</span><br><span class="line">    value: &apos;Jake&apos;  // 设置name属性的值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 再次delete，已经不能删除了</span><br><span class="line">delete person.name   // false</span><br><span class="line"></span><br><span class="line">console.log(person.name)    // 值为Jake</span><br><span class="line"></span><br><span class="line">// 试图改变value</span><br><span class="line">person.name = &quot;alex&quot;;</span><br><span class="line">console.log(person.name) // Jake 改变失败</span><br></pre></td></tr></table></figure><p><strong>enumerable</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;TOM&apos;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用for-in枚举person的属性</span><br><span class="line">var params = [];</span><br><span class="line"></span><br><span class="line">for(var key in person) &#123;</span><br><span class="line">    params.push(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看枚举结果</span><br><span class="line">console.log(params);  // [&apos;name&apos;, &apos;age&apos;]</span><br><span class="line"></span><br><span class="line">// 重新设置name属性的类型，让其不可被枚举</span><br><span class="line">Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">    enumerable: false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var params_ = [];</span><br><span class="line">for(var key in person) &#123;</span><br><span class="line">    params_.push(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 再次查看枚举结果</span><br><span class="line">console.log(params_); // [&apos;age&apos;]</span><br></pre></td></tr></table></figure><p><strong>writable</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;TOM&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改name的值</span><br><span class="line">person.name = &apos;Jake&apos;;</span><br><span class="line"></span><br><span class="line">// 查看修改结果</span><br><span class="line">console.log(person.name); // Jake 修改成功</span><br><span class="line"></span><br><span class="line">// 设置name的值不能被修改</span><br><span class="line">Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">    writable: false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 再次试图修改name的值</span><br><span class="line">person.name = &apos;alex&apos;;</span><br><span class="line"></span><br><span class="line">console.log(person.name); // Jake 修改失败</span><br></pre></td></tr></table></figure><p><strong>value</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 添加一个name属性</span><br><span class="line">Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">    value: &apos;TOM&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(person.name)  // TOM</span><br></pre></td></tr></table></figure><p><strong>get/set</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 通过get与set自定义访问与设置name属性的方式</span><br><span class="line">Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        // 一直返回TOM</span><br><span class="line">        return &apos;TOM&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(value) &#123;</span><br><span class="line">        // 设置name属性时，返回该字符串，value为新值</span><br><span class="line">        console.log(value + &apos; in set&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 第一次访问name，调用get</span><br><span class="line">console.log(person.name)   // TOM</span><br><span class="line"></span><br><span class="line">// 尝试修改name值，此时set方法被调用</span><br><span class="line">person.name = &apos;alex&apos;   // alex in set</span><br><span class="line"></span><br><span class="line">// 第二次访问name，还是调用get</span><br><span class="line">console.log(person.name) // TOM</span><br></pre></td></tr></table></figure><blockquote><p>请尽量同时设置get、set。如果仅仅只设置了get，那么我们将无法设置该属性值。如果仅仅只设置了set，我们也无法读取该属性的值。</p></blockquote><p><code>Object.defineProperty</code>只能设置一个属性的属性特性。当我们想要同时设置多个属性的特性时，需要使用我们之前提到过的<code>Object.defineProperties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &apos;Jake&apos;,</span><br><span class="line">        configurable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return this.value || 22</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(value) &#123;</span><br><span class="line">            this.value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.name   // Jake</span><br><span class="line">person.age    // 22</span><br></pre></td></tr></table></figure><h6 id="读取属性的特性值"><a href="#读取属性的特性值" class="headerlink" title="读取属性的特性值"></a>读取属性的特性值</h6><p>我们可以使用<code>Object.getOwnPropertyDescriptor</code>方法读取某一个属性的特性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">    value: &apos;alex&apos;,</span><br><span class="line">    writable: false,</span><br><span class="line">    configurable: false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var descripter = Object.getOwnPropertyDescriptor(person, &apos;name&apos;);</span><br><span class="line"></span><br><span class="line">console.log(descripter);  // 返回结果如下</span><br><span class="line"></span><br><span class="line">descripter = &#123;</span><br><span class="line">    configurable: false,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    value: &apos;alex&apos;,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h5><p>关于面向对象的基础知识大概就是这些了。我从最简单的创建一个对象开始，解释了为什么我们需要构造函数与原型，理解了这其中的细节，有助于我们在实际开发中灵活的组织自己的对象。因为我们并不是所有的场景都会使用构造函数或者原型来创建对象，也许我们需要的对象并不会声明多个实例，或者不用区分对象的类型，那么我们就可以选择更简单的方式。</p><p>我们还需要关注构造函数与原型的各自特性，有助于我们在创建对象时准确的判断我们的属性与方法到底是放在构造函数中还是放在原型中。如果没有理解清楚，这会给我们在实际开发中造成非常大的困扰。</p>]]></content>
    
    <summary type="html">
    
      面向对象
    
    </summary>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://yoursite.com/2019/01/06/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/06/函数柯里化/</id>
    <published>2019-01-06T07:31:52.000Z</published>
    <updated>2019-01-06T07:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>柯里化是函数的一个比较高级的应用，想要理解它并不简单。因此我一直在思考应该如何更加表达才能让大家理解起来更加容易。</p><p>以下是新版本讲解。高阶函数章节由于一些原因并未公开，大家可以自行搜索学习</p><p>通过上一个章节的学习我们知道，接收函数作为参数的函数，都可以叫做高阶函数。我们常常利用高阶函数来封装一些公共的逻辑。<br>这一章我们要学习的柯里化，其实就是高阶函数的一种特殊用法。<br>柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。<br>这样的定义可能不太好理解，我们可以通过下面的例子配合理解。<br>假如有一个接收三个参数的函数A。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又假如我们有一个已经封装好了的柯里化通用函数createCurry。他接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _A = createCurry(A);</span><br></pre></td></tr></table></figure><p>那么_A作为createCurry运行的返回函数，他能够处理A的剩余参数。因此下面的运行结果都是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">A(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>函数A被createCurry转化之后得到柯里化函数_A，_A能够处理A的所有剩余参数。因此柯里化也被称为部分求值。<br>在简单的场景下，我们可以不用借助柯里化通用式来转化得到柯里化函数，我们可以凭借眼力自己封装。<br>例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么add函数的柯里化函数_add则可以如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此下面的运算方式是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">_add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>当然，柯里化通用式具备更加强大的能力，我们靠眼力自己封装的柯里化函数则自由度偏低。因此我们仍然需要知道自己如何去封装这样一个柯里化的通用式。<br>首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装。<br>封装如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单实现，参数只能从右到左传递</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCurry</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arity = func.length;</span><br><span class="line">    <span class="keyword">var</span> args = args || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        [].push.apply(_args, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span></span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; arity) &#123;</span><br><span class="line">            <span class="keyword">return</span> createCurry.call(<span class="keyword">this</span>, func, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数收集完毕，则执行func</span></span><br><span class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我已经做了足够详细的注解，但是我想理解起来也并不是那么容易，因此建议大家用点耐心多阅读几遍。这个createCurry函数的封装借助闭包与递归，实现了一个参数收集，并在收集完毕之后执行所有参数的一个过程。<br>因此聪明的读者可能已经发现，把函数经过createCurry转化为一个柯里化函数，最后执行的结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？<br>如果你能够提出这样的问题，那么说明你确实已经对柯里化有了一定的了解。柯里化确实是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。而这里对于函数参数的自由处理，正是柯里化的核心所在。<br>我们来举一个非常常见的例子。<br>如果我们想要验证一串数字是否是正确的手机号，那么按照普通的思路来做，大家可能是这样封装，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>.test(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果我们想要验证是否是邮箱呢？这么封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEmail</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">targetString, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(targetString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">'14900000088'</span>);</span><br><span class="line">check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>);</span><br></pre></td></tr></table></figure><p>那么这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _check = createCurry(check);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPhone = _check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure><p>最后在使用的时候就会变得更加直观与简洁了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPhone(<span class="string">'183888888'</span>);</span><br><span class="line">checkEmail(<span class="string">'xxxxx@test.com'</span>);</span><br></pre></td></tr></table></figure><p>经过这个过程我们发现，柯里化能够应对更加复杂的逻辑封装。当情况变得多变，柯里化依然能够应付自如。<br>虽然柯里化确实在一定程度上将问题复杂化了，也让代码更加不容易理解，但是柯里化在面对复杂情况下的灵活性却让我们不得不爱。<br>当然这个案例本身情况还算简单，所以还不能够特别明显的凸显柯里化的优势，我们的主要目的在于借助这个案例帮助大家了解柯里化在实践中的用途。<br>我们继续来思考一个例子。这个例子与map有关。在高阶函数的章节中，我们分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。<br>但是，这是针对了所有的情况我们才会这样想。<br>实践中我们常常会发现，在我们的某个项目中，针对于某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。<br>于是，这个时候，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中的使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转化为百分比 1 –&gt; 100%。<br>普通思维下我们可以这样来封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNewArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item * <span class="number">100</span> + <span class="string">'%'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNewArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.12</span>]);   <span class="comment">// ['100%', '200%', '300%', '12%'];</span></span><br></pre></td></tr></table></figure><p>而如果借助柯里化来二次封装这样的逻辑，则会如下实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_map</span>(<span class="params">func, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.map(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _getNewArray = createCurry(_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNewArray = _getNewArray(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">100</span> + <span class="string">'%'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">getNewArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.12</span>]);   <span class="comment">// ['100%', '200%', '300%', '12%'];</span></span><br><span class="line">getNewArray([<span class="number">0.01</span>, <span class="number">1</span>]); <span class="comment">// ['1%', '100%']</span></span><br></pre></td></tr></table></figure><p>如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_filter</span>(<span class="params">func, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.filter(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _find = createCurry(_filter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumber = _find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">findNumber([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们继续封装另外的过滤操作时就会变得非常简单</span></span><br><span class="line"><span class="comment">// 找出数字为20的子项</span></span><br><span class="line"><span class="keyword">var</span> find20 = _find(<span class="function"><span class="keyword">function</span>(<span class="params">item, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">find20([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">100</span>]);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出数组中大于100的所有数据</span></span><br><span class="line"><span class="keyword">var</span> findGreater100 = _find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">findGreater100([<span class="number">1</span>, <span class="number">2</span>, <span class="number">101</span>, <span class="number">300</span>, <span class="number">2</span>, <span class="number">122</span>]); <span class="comment">// [101, 300, 122]</span></span><br></pre></td></tr></table></figure><p>我采用了与check例子不一样的思维方向来想大家展示我们在使用柯里化时的想法。目的是想告诉大家，柯里化能够帮助我们应对更多更复杂的场景。<br>当然不得不承认，这些例子都太简单了，简单到如果使用柯里化的思维来处理他们显得有一点多此一举，而且变得难以理解。因此我想读者朋友们也很难从这些例子中感受到柯里化的魅力。不过没关系，如果我们能够通过这些例子掌握到柯里化的思维，那就是最好的结果了。在未来你的实践中，如果你发现用普通的思维封装一些逻辑慢慢变得困难，不妨想一想在这里学到的柯里化思维，应用起来，柯里化足够强大的自由度一定能给你一个惊喜。<br>当然也并不建议在任何情况下以炫技为目的的去使用柯里化，在柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的。只有在情况变得复杂时，才是柯里化大显身手的时候。</p><h1 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h1><p>无限参数的柯里化。</p><p>该部分内容可忽略</p><p>在前端面试中，你可能会遇到这样一个涉及到柯里化的题目。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>这个题目的目的是想让add执行之后返回一个函数能够继续执行，最终运算的结果是所有出现过的参数之和。而这个题目的难点则在于参数的不固定。我们不知道函数会执行几次。因此我们不能使用上面我们封装的createCurry的通用公式来转换一个柯里化函数。只能自己封装，那么怎么办呢？在此之前，补充2个非常重要的知识点。<br>一个是ES6函数的不定参数。假如我们有一个数组，希望把这个数组中所有的子项展开传递给一个函数作为参数。那么我们应该怎么做？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大家可以思考一下，如果将args数组的子项展开作为add的参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>在ES5中，我们可以借助之前学过的apply来达到我们的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.apply(<span class="literal">null</span>, args);  <span class="comment">// 105</span></span><br></pre></td></tr></table></figure><p>而在ES6中，提供了一种新的语法来解决这个问题，那就是不定参。写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(...args);  <span class="comment">// 105</span></span><br></pre></td></tr></table></figure><p>这两种写法是等效的。OK，先记在这里。在接下的实现中，我们会用到不定参数的特性。<br>第二个要补充的知识点是函数的隐式转换。当我们直接将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>);     <span class="comment">// 输出结果 function fn() &#123; return 20 &#125;10</span></span><br></pre></td></tr></table></figure><p>但是我们可以重写函数的toString方法，让函数参与计算时，输出我们想要的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure><p>当我们同时重写函数的toString方法与valueOf方法时，最终的结果会取valueOf方法的返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">50</span> &#125;</span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure><p>补充了这两个知识点之后，我们可以来尝试完成之前的题目了。add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// [].push.apply(_args, [].slice.call(arguments));</span></span><br><span class="line">            _args.push(...arguments);</span><br><span class="line">            <span class="keyword">return</span> _adder;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return adder.apply(null, _args);</span></span><br><span class="line">    <span class="keyword">return</span> adder(..._args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"><span class="keyword">var</span> b = add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"><span class="keyword">var</span> c = add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"><span class="keyword">var</span> d = add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>);   <span class="comment">// f 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以利用隐式转换的特性参与计算</span></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">10</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(c + <span class="number">30</span>); <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">console</span>.log(d + <span class="number">40</span>); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算</span></span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(b(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(c(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(d(<span class="number">10</span>) + <span class="number">100</span>);  <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为老版本讲解，请勿阅读学习，因为部分思维并不完全正确。</p><h1 id="一、补充知识点之函数的隐式转换"><a href="#一、补充知识点之函数的隐式转换" class="headerlink" title="一、补充知识点之函数的隐式转换"></a>一、补充知识点之函数的隐式转换</h1><p>JavaScript作为一种弱类型语言，它的隐式转换是非常灵活有趣的。当我们没有深入了解隐式转换的时候可能会对一些运算的结果会感动困惑，比如4 + true = 5。当然，如果对隐式转换了解足够深刻，肯定是能够很大程度上提高对js的使用能力。只是我没有打算将所有的隐式转换规则分享给大家，这里暂时只分享一下，函数在隐式转换中的一些规则。<br>来一个简单的思考题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 输出结果是多少？</span></span><br></pre></td></tr></table></figure><p>稍微修改一下，再想想输出结果会是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>);  <span class="comment">// 输出结果是多少？</span></span><br></pre></td></tr></table></figure><p>还可以继续修改一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 输出结果是多少？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果分别为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>当使用console.log，或者进行运算时，隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。</p><p>当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行</p><p>因此上面例子的结论就很容易理解了。建议大家动手尝试一下。</p><h1 id="二、补充知识点之利用call-apply封数组的map方法"><a href="#二、补充知识点之利用call-apply封数组的map方法" class="headerlink" title="二、补充知识点之利用call/apply封数组的map方法"></a>二、补充知识点之利用call/apply封数组的map方法</h1><p>map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p><p>通俗来说，就是遍历数组的每一项元素，并且在map的第一个参数（回调函数）中进行运算处理后返回计算结果。返回一个由所有计算结果组成的新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数中有三个参数</span></span><br><span class="line"><span class="comment">// 第一个参数表示newArr的每一项，第二个参数表示该项在数组中的索引值</span></span><br><span class="line"><span class="comment">// 第三个表示数组本身</span></span><br><span class="line"><span class="comment">// 除此之外，回调函数中的this，当map不存在第二参数时，this指向丢失，当存在第二个参数时，指向改参数所设定的对象</span></span><br><span class="line"><span class="keyword">var</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">item, i, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, i, arr, <span class="keyword">this</span>);  <span class="comment">// 可运行试试看</span></span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>;  <span class="comment">// 每一项加1</span></span><br><span class="line">&#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>在上面例子的注释中详细阐述了map方法的细节。现在要面临一个难题，就是如何封装map。<br>可以先想想for循环。我们可以使用for循环来实现一个map，但是在封装的时候，我们会考虑一些问题。我们在使用for循环的时候，一个循环过程确实很好封装，但是我们在for循环里面要对每一项做的事情却很难用一个固定的东西去把它封装起来。因为每一个场景，for循环里对数据的处理肯定都是不一样的。<br>于是大家就想了一个很好的办法，将这些不一样的操作单独用一个函数来处理，让这个函数成为map方法的第一个参数，具体这个回调函数中会是什么样的操作，则由我们自己在使用时决定。因此，根据这个思路的封装实现如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fn == <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">        <span class="comment">// 封装for循环过程</span></span><br><span class="line">        <span class="keyword">for</span>(; k &lt; len; k++) &#123;</span><br><span class="line">            <span class="comment">// 将每一项的运算操作丢进fn里，利用call方法指定fn的this指向与具体参数</span></span><br><span class="line">            temp.push(fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'TypeError: '</span>+ fn +<span class="string">' is not a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回每一项运算结果组成的新数组</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]._map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p><p>在上面的封装中，我首先定义了一个空的temp数组，该数组用来存储最终的返回结果。在for循环中，每循环一次，就执行一次参数fn函数，fn的参数则使用call方法传入。</p><p>在理解了map的封装过程之后，我们就能够明白为什么我们在使用map时，总是期望能够在第一个回调函数中有一个返回值了。在eslint的规则中，如果我们在使用map时没有设置一个返回值，就会被判定为错误。</p><p>ok，明白了函数的隐式转换规则与call/apply在这种场景的使用方式，我们就可以尝试通过简单的例子来了解一下柯里化了。</p><h1 id="三、由浅入深的柯里化"><a href="#三、由浅入深的柯里化" class="headerlink" title="三、由浅入深的柯里化"></a>三、由浅入深的柯里化</h1><p>在前端面试中有一个关于柯里化的面试题，流传甚广。</p><p>实现一个add方法，使计算结果能够满足如下预期：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span></span><br></pre></td></tr></table></figure><br>很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。<br>我们可以从最简单的例子一步一步寻找解决方案。<br>当我们只调用两次时，可以这样封装。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>));  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>如果只调用三次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面的封装看上去跟我们想要的结果有点类似，但是参数的使用被限制得很死，因此并不是我们想要的最终结果，我们需要通用的封装。应该怎么办？总结一下上面2个例子，其实我们是利用闭包的特性，将所有的参数，集中到最后返回的函数里进行计算并返回结果。因此我们在封装时，主要的目的，就是将参数集中起来计算。<br>来看看具体实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            [].push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">            <span class="keyword">return</span> _adder;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adder.apply(<span class="literal">null</span>, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，可自由组合的参数</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>上面的实现，利用闭包的特性，主要目的是想通过一些巧妙的方法将所有的参数收集在一个数组里，并在最终隐式转换时将数组里的所有项加起来。因此我们在调用add方法的时候，参数就显得非常灵活。当然，也就很轻松的满足了我们的需求。<br>那么读懂了上面的demo，然后我们再来看看柯里化的定义，相信大家就会更加容易理解了。</p><p>柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。</p><p>接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。<br>将部分参数通过回调函数等方式传入函数中<br>返回一个新函数，用于处理所有的想要传入的参数</p><p>在上面的例子中，我们可以将add(1, 2, 3, 4)转换为add(1)(2)(3)(4)。这就是部分求值。每次传入的参数都只是我们想要传入的所有参数中的一部分。当然实际应用中，并不会常常这么复杂的去处理参数，很多时候也仅仅只是分成两部分而已。<br>咱们再来一起思考一个与柯里化相关的问题。</p><p>假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连起来。我们应该怎么做？想到使用join方法，就很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际开发中并不建议直接给Array扩展新的方法</span></span><br><span class="line"><span class="comment">// 只是用这种方式演示能够更加清晰一点</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">chars</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> string = arr.merge(<span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(string);  <span class="comment">// 1-2-3-4-5</span></span><br><span class="line"></span><br><span class="line">增加难度，将每一项加一个数后再连起来。那么这里就需要map来帮助我们对每一项进行特殊的运算处理，生成新的数组然后用字符连接起来了。实现如下：</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">chars, number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item + number;</span><br><span class="line">    &#125;).join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> string = arr.merge(<span class="string">'-'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// 2-3-4-5-6</span></span><br></pre></td></tr></table></figure><p>但是如果我们又想要让数组每一项都减去一个数之后再连起来呢？当然和上面的加法操作一样的实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">chars, number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item - number;</span><br><span class="line">    &#125;).join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> string = arr.merge(<span class="string">'~'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// 0~1~2~3~4</span></span><br></pre></td></tr></table></figure></p><p>机智的小伙伴肯定发现困惑所在了。我们期望封装一个函数，能同时处理不同的运算过程，但是我们并不能使用一个固定的套路将对每一项的操作都封装起来。于是问题就变成了和封装map的时候所面临的问题一样了。我们可以借助柯里化来搞定。<br>与map封装同样的道理，既然我们事先并不确定我们将要对每一项数据进行怎么样的处理，我只是知道我们需要将他们处理之后然后用字符连起来，所以不妨将处理内容保存在一个函数里。而仅仅固定封装连起来的这一部分需求。<br>于是我们就有了以下的封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装很简单，一句话搞定</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">fn, chars</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(fn).join(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 难点在于，在实际使用的时候，操作怎么来定义，利用闭包保存于传递num参数</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item + num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> red = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item - num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一项加2后合并</span></span><br><span class="line"><span class="keyword">var</span> res1 = arr.merge(add(<span class="number">2</span>), <span class="string">'-'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一项减2后合并</span></span><br><span class="line"><span class="keyword">var</span> res2 = arr.merge(red(<span class="number">1</span>), <span class="string">'-'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接使用回调函数，每一项乘2后合并</span></span><br><span class="line"><span class="keyword">var</span> res3 = arr.merge((<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item * num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="number">2</span>), <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 3-4-5-6</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 0-1-2-3</span></span><br><span class="line"><span class="built_in">console</span>.log(res3); <span class="comment">// 2-4-6-8</span></span><br></pre></td></tr></table></figure><p>大家能从上面的例子，发现柯里化的特征吗？</p><h1 id="四、柯里化通用式"><a href="#四、柯里化通用式" class="headerlink" title="四、柯里化通用式"></a>四、柯里化通用式</h1><p>通用的柯里化写法其实比我们上边封装的add方法要简单许多。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 主要还是收集所有需要的参数到一个数组中，便于统一计算</span></span><br><span class="line">        <span class="keyword">var</span> _args = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">10</span>));  <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">5</span>));   <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></p><h1 id="五、柯里化与bind"><a href="#五、柯里化与bind" class="headerlink" title="五、柯里化与bind"></a>五、柯里化与bind</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子利用call与apply的灵活运用，实现了bind的功能。<br>在前面的几个例子中，我们可以总结一下柯里化的特点：</p><p>接收单一参数，将更多的参数通过回调函数来搞定？<br>返回一个新函数，用于处理所有的想要传入的参数；<br>需要利用call/apply与arguments对象收集参数；<br>返回的这个函数正是用来处理收集起来的参数。</p><p>希望大家读完之后都能够大概明白柯里化的概念，如果想要熟练使用它，就需要我们掌握更多的实际经验才行。</p>]]></content>
    
    <summary type="html">
    
      函数柯里化
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数与函数式编程</title>
    <link href="http://yoursite.com/2018/12/29/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/29/函数与函数式编程/</id>
    <published>2018-12-29T10:00:00.000Z</published>
    <updated>2018-12-29T14:25:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。</p><p>所以，大家一定要重视函数！</p><p>当然，关于函数的重点，难点在前面几篇文章都已经说得差不多了，这篇文章主要总结一下函数的基础知识，并初步学习函数式编程的思维。</p><h5 id="一、函数声明、函数表达式、匿名函数与自执行函数"><a href="#一、函数声明、函数表达式、匿名函数与自执行函数" class="headerlink" title="一、函数声明、函数表达式、匿名函数与自执行函数"></a>一、函数声明、函数表达式、匿名函数与自执行函数</h5><p>关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。</p><p><strong>函数声明</strong></p><p>我们知道，JavaScript中，有两种声明方式，一个是使用<code>var</code>的变量声明，另一个是使用<code>function</code>的函数声明。</p><p>在<a href="https://www.jianshu.com/p/330b1505e41d" target="_blank" rel="noopener">前端基础进阶（三）：变量对象详解</a>中我有提到过，变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn();  // function</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&apos;function&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 函数表达式 </strong></p><p>与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明</span><br><span class="line">var a = 20;</span><br><span class="line"></span><br><span class="line">// 实际执行顺序</span><br><span class="line">var a = undefined;  // 变量声明，初始值undefined，变量提升，提升顺序次于function声明</span><br><span class="line">a = 20;  // 变量赋值，该操作不会提升</span><br></pre></td></tr></table></figure><p>同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn(); // 报错</span><br><span class="line">var fn = function() &#123;</span><br><span class="line">    console.log(&apos;function&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例子的执行顺序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn = undefined;   // 变量声明提升</span><br><span class="line">fn();    // 执行报错</span><br><span class="line">fn = function() &#123;   // 赋值操作，此时将后边函数的引用赋值给fn</span><br><span class="line">    console.log(&apos;function&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。</p></blockquote><p>关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在构造函数中添加方法</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    // 在构造函数内部中添加方法</span><br><span class="line">    this.getAge = function() &#123;</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">    this.</span><br><span class="line">&#125;</span><br><span class="line">// 给原型添加方法</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在对象中添加方法</span><br><span class="line">var a = &#123;</span><br><span class="line">    m: 20,</span><br><span class="line">    getM: function() &#123;</span><br><span class="line">        return this.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名函数</strong></p><p>在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var fn = function(bar, num) &#123;</span><br><span class="line">    return bar() + num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(function() &#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;, 20)</span><br></pre></td></tr></table></figure><p>在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 变量对象在fn上下文执行过程中的创建阶段</span><br><span class="line">VO(fn) = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        bar: undefined,</span><br><span class="line">        num: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 变量对象在fn上下文执行过程中的执行阶段</span><br><span class="line">// 变量对象变为活动对象，并完成赋值操作与执行可执行代码</span><br><span class="line">VO -&gt; AO</span><br><span class="line"></span><br><span class="line">AO(fn) = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        bar: function() &#123; return a &#125;,</span><br><span class="line">        num: 20,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为<strong>回调函数</strong>。关于匿名函数更多的内容，我会在下一篇深入探讨柯里化的文章中进行更加详细讲解。</p><p><strong>匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点</strong>，因此我们一定要对它的这些细节了解的足够清楚，如果对于变量对象的演变过程你还看不太明白，一定要回过头去看这篇文章：<a href="https://www.jianshu.com/p/330b1505e41d" target="_blank" rel="noopener">前端基础进阶（三）：变量对象详解</a></p><p><strong>函数自执行与块级作用域</strong></p><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实是匿名函数的一种应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">   // ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p><p>根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    // 私有变量</span><br><span class="line">    var age = 20;</span><br><span class="line">    var name = &apos;Tom&apos;;</span><br><span class="line"></span><br><span class="line">    // 私有方法</span><br><span class="line">    function getName() &#123;</span><br><span class="line">        return `your name is ` + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的<strong>闭包</strong>的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。</p><blockquote><p>如果你对闭包了解不够，<a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a>应该可以帮到你。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    // 私有变量</span><br><span class="line">    var age = 20;</span><br><span class="line">    var name = &apos;Tom&apos;;</span><br><span class="line"></span><br><span class="line">    // 私有方法</span><br><span class="line">    function getName() &#123;</span><br><span class="line">        return `your name is ` + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 共有方法</span><br><span class="line">    function getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收</span><br><span class="line">    window.getAge = getAge;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>当然，闭包在模块中的重要作用，我们也在讲解闭包的时候已经强调过，但是这个知识点真的太重要，需要我们反复理解并且彻底掌握，因此为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 使用函数自执行的方式创建模块</span><br><span class="line">(function(window, undefined) &#123;</span><br><span class="line"></span><br><span class="line">    // 声明jQuery构造函数</span><br><span class="line">     var jQuery = function(name) &#123;</span><br><span class="line"></span><br><span class="line">        // 主动在构造函数中，返回一个jQuery实例</span><br><span class="line">         return new jQuery.fn.init(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    // 添加原型方法</span><br><span class="line">     jQuery.prototype = jQuery.fn = &#123;</span><br><span class="line">         constructor: jQuery,</span><br><span class="line">         init:function() &#123; ... &#125;,</span><br><span class="line">         css: function() &#123; ... &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了</span><br><span class="line">     window.jQuery = window.$ = jQuery;</span><br><span class="line"> &#125;)(window);</span><br><span class="line"></span><br><span class="line">// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了</span><br><span class="line">$(&apos;#div1&apos;);</span><br></pre></td></tr></table></figure><p>在这里，我们只需要看懂闭包与模块的部分就行了，至于内部的原型链是如何绕的，为什么会这样写，我在讲面向对象的时候会为大家慢慢分析。举这个例子的目的所在，就是希望大家能够重视函数，因为在实际开发中，它无处不在。</p><p>接下来我要分享一个高级的，非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，有一个叫做状态管理器的东西就应运而生。对于状态管理器，最出名的，我想非redux莫属了。虽然对于还在学习中的大家来说，redux是一个有点高深莫测的东西，但是在我们学习之前，可以先通过简单的方式，让大家大致了解状态管理器的实现原理，为我们未来的学习奠定坚实的基础。</p><p>先来直接看代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 自执行创建模块</span><br><span class="line">(function() &#123;</span><br><span class="line">    // states 结构预览</span><br><span class="line">    // states = &#123;</span><br><span class="line">    //     a: 1,</span><br><span class="line">    //     b: 2,</span><br><span class="line">    //     m: 30,  </span><br><span class="line">    //     o: &#123;&#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    var states = &#123;&#125;;  // 私有变量，用来存储状态与数据</span><br><span class="line"></span><br><span class="line">    // 判断数据类型</span><br><span class="line">    function type(elem) &#123;</span><br><span class="line">        if(elem == null) &#123;</span><br><span class="line">            return elem + &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return toString.call(elem).replace(/[\[\]]/g, &apos;&apos;).split(&apos; &apos;)[1].toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @Param name 属性名</span><br><span class="line">     * @Description 通过属性名获取保存在states中的值</span><br><span class="line">    */</span><br><span class="line">    function get(name) &#123;</span><br><span class="line">        return states[name] ? states[name] : &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getStates() &#123;</span><br><span class="line">        return states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * @param options &#123;object&#125; 键值对</span><br><span class="line">    * @param target &#123;object&#125; 属性值为对象的属性，只在函数实现时递归中传入</span><br><span class="line">    * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似</span><br><span class="line">    */</span><br><span class="line">    function set(options, target) &#123;</span><br><span class="line">        var keys = Object.keys(options);</span><br><span class="line">        var o = target ? target : states;</span><br><span class="line"></span><br><span class="line">        keys.map(function(item) &#123;</span><br><span class="line">            if(typeof o[item] == &apos;undefined&apos;) &#123;</span><br><span class="line">                o[item] = options[item];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                type(o[item]) == &apos;object&apos; ? set(options[item], o[item]) : o[item] = options[item];</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对外提供接口</span><br><span class="line">    window.get = get;</span><br><span class="line">    window.set = set;</span><br><span class="line">    window.getStates = getStates;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 具体使用如下</span><br><span class="line"></span><br><span class="line">set(&#123; a: 20 &#125;);     // 保存 属性a</span><br><span class="line">set(&#123; b: 100 &#125;);    // 保存属性b</span><br><span class="line">set(&#123; c: 10 &#125;);     // 保存属性c</span><br><span class="line"></span><br><span class="line">// 保存属性o, 它的值为一个对象</span><br><span class="line">set(&#123;</span><br><span class="line">    o: &#123;</span><br><span class="line">        m: 10,</span><br><span class="line">        n: 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 修改对象o 的m值</span><br><span class="line">set(&#123;</span><br><span class="line">    o: &#123;</span><br><span class="line">        m: 1000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 给对象o中增加一个c属性</span><br><span class="line">set(&#123;</span><br><span class="line">    o: &#123;</span><br><span class="line">        c: 100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(getStates())</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/yangbo5207/pen/EZzEbY?editors=1111" target="_blank" rel="noopener">demo实例在线地址</a></p><p>我之所以说这是一个高级应用，是因为在单页应用中，我们很可能会用到这样的思路。根据我们提到过的知识，理解这个例子其实很简单，其中的难点估计就在于set方法的处理上，因为为了具有更多的适用性，因此做了很多适配，用到了递归等知识。如果你暂时看不懂，没有关系，知道如何使用就行了，上面的代码可以直接运用于实际开发。记住，当你需要保存的状态太多的时候，你就想到这一段代码就行了。</p><blockquote><p>函数自执行的方式另外还有其他几种写法，诸如<code>!function(){}()</code>，<code>+function(){}()</code></p></blockquote><h5 id="二、函数参数传递方式：按值传递"><a href="#二、函数参数传递方式：按值传递" class="headerlink" title="二、函数参数传递方式：按值传递"></a>二、函数参数传递方式：按值传递</h5><p>还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var b = a;</span><br><span class="line">b = 10;</span><br><span class="line">console.log(a);  // 20</span><br><span class="line"></span><br><span class="line">var m = &#123; a: 1, b: 2 &#125;</span><br><span class="line">var n = m;</span><br><span class="line">n.a = 5;</span><br><span class="line">console.log(m.a) // 5</span><br></pre></td></tr></table></figure><p>当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line"></span><br><span class="line">function fn(a) &#123;</span><br><span class="line">    a = a + 10;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line">console.log(a); // 20</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; m: 10, n: 20 &#125;</span><br><span class="line">function fn(a) &#123;</span><br><span class="line">    a.m = 20;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(a);</span><br><span class="line">console.log(a);   // &#123; m: 20, n: 20 &#125;</span><br></pre></td></tr></table></figure><p>正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;Nicholas&apos;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setName(obj) &#123;  // 传入一个引用</span><br><span class="line">    obj = &#123;&#125;;   // 将传入的引用指向另外的值</span><br><span class="line">    obj.name = &apos;Greg&apos;;  // 修改引用的name属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setName(person);</span><br><span class="line">console.log(person.name);  // Nicholas 未被改变</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。</p><h5 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h5><p>虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。</p><p>当我们想要使用一个函数时，通常情况下其实就是想要将一些功能，逻辑等封装起来。相信大家对于封装这个概念并不陌生。</p><p>我们通常通过函数封装来完成一件事情。例如，我想要计算任意三个数的和，我们就可以将这三个数作为参数，封装一个简单的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要计算三个数的和时，直接调用该方法即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(1, 2, 3); // 6</span><br></pre></td></tr></table></figure><p>当然，当我们想要做的事情比较简单的时候，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目的和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function mergeArr(arr) &#123;</span><br><span class="line">    var result = 0;</span><br><span class="line">    for(var i = 0; i &lt; arr.length; i++) &#123; result  += arr[i] &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们的代码中充斥着越来越多的重复代码。而封装之后，当我们想要再次做这件事情的时候，只需要一句话就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mergeArr([1, 2, 3, 4, 5]);</span><br></pre></td></tr></table></figure><p>当然，我相信大家对于函数封装的意义都应该有非常明确的认知，但是我们要面临的问题是，当我们想要去封装一个函数时，如何做才是最佳实践呢？</p><p>函数式编程能给我们答案。</p><p>我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式编程更加的简单，直白。例如我们现在有一个数组，<code>array = [1, 3, &#39;h&#39;, 5, &#39;m&#39;, &#39;4&#39;]</code>，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式编程思维时，可能就会直接这样做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 3, &apos;h&apos;, 5, &apos;m&apos;, &apos;4&apos;];</span><br><span class="line">var res = [];</span><br><span class="line">for(var i = 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">    if (typeof array[i] === &apos;number&apos;) &#123;</span><br><span class="line">        res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。</p><p>而函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getNumbers(array) &#123;</span><br><span class="line">    var res = [];</span><br><span class="line">    array.forEach(function(item) &#123;</span><br><span class="line">        if (typeof item === &apos;number&apos;) &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以上是我们的封装，以下是功能实现</span><br><span class="line">var array = [1, 3, &apos;h&apos;, 5, &apos;m&apos;, &apos;4&apos;];</span><br><span class="line">var res = getNumbers(array);</span><br></pre></td></tr></table></figure><p>因此当我们将功能封装之后，我们实现同样的功能时，只需要写一行代码。而如果未来需求变动，或者稍作修改，我们只需要对getNumbers方法进行调整就可以了。而且我们在使用时，只需要关心这个方法能做什么，而不用关心他具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一。</p><p>函数式编程思维还具有以下几个特征。</p><p><strong>函数是第一等公民</strong></p><p>所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = function foo() &#123;&#125;  // 赋值</span><br><span class="line">function fn(function() &#123;&#125;, num) &#123;&#125;   // 函数作为参数</span><br><span class="line"></span><br><span class="line">// 函数作为返回值</span><br><span class="line">function var() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这都是JavaScript的基本概念。但是我想很多人，甚至包括正在阅读的你自己都可能会无视这些概念。可以用一个简单的例子来验证一下。</p><p>我们先自定义这样一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function delay() &#123;</span><br><span class="line">    console.log(&apos;5000ms之后执行该方法.&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要做的是，如果要求你结合setTimeout方法，让delay方法延迟5000ms执行，应该怎么做？</p><p>其实很简单，对不对，直接这样就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var timer = setTimeout(function() &#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><p>那么现在问题来了，如果你对函数是一等公民有一个深刻的认知，我想你会发现上面这种写法其实是有一些问题的。所以思考一下，问题出在哪里？</p><p>函数既然能够作为一个参数传入另外一个函数，那么我们是不是可以直接将delay作为setTimeout的第一个参数，而不用额外的多加一层匿名函数呢？</p><p>因此，其实最正确的解法应该这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timer = setTimeout(delay, 5000);</span><br></pre></td></tr></table></figure><p>当然，如果你已经提前想到这样做了，那么恭喜你，说明你在JavaScript上比普通人更有天赋。其实第一种糟糕的方式很多人都在用，包括有多年工作经验的人也没有完全避免。而他们甚至还不知道自己问题出在什么地方。</p><p>在未来的实践中，你还会遇到更多类似的场景。为了验证读者朋友们的理解，我们不妨来思考一下如何优化下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getUser(path, callback) &#123;</span><br><span class="line">    return $.get(path, function(info) &#123;</span><br><span class="line">        return callback(info);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUser(&apos;/api/user&apos;, function(resp) &#123;</span><br><span class="line">    // resp为成功请求之后返回的数据</span><br><span class="line">    console.log(resp);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优化的原理和setTimeout的例子一模一样，我这里卖个关子，不打算告诉大家结论，仅提示一句，getUser优化之后，仅有一句代码。考验大家学习成果的时候到了 ^ ^。</p><p><strong>只用”表达式”，不用”语句”</strong></p><p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>假如我们的项目中，多处需要改变某个元素的背景色。因此我们可以这样封装一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ele = document.querySelector(&apos;.test&apos;);</span><br><span class="line">function setBackgroundColor(color) &#123;</span><br><span class="line">    ele.style.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多处使用</span><br><span class="line">setBackgroundColor(&apos;red&apos;);</span><br><span class="line">setBackgroundColor(&apos;#ccc&apos;);</span><br></pre></td></tr></table></figure><p>我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式编程期望一个函数有输入，也有输出。因此良好的习惯应该如下做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function setBackgroundColor(ele, color) &#123;</span><br><span class="line">    ele.style.backgroundColor = color;</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多处使用</span><br><span class="line">var ele = document.querySelector(&apos;.test&apos;);</span><br><span class="line">setBackgroundColor(ele, &apos;red&apos;);</span><br><span class="line">setBackgroundColor(ele, &apos;#ccc&apos;);</span><br></pre></td></tr></table></figure><p>了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。</p><p><strong>纯函数</strong></p><p>相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。</p><p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p><p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><p>即所谓的只要是同样的参数传入，返回的结果一定是相等的。</p><p>例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getLast(arr) &#123;</span><br><span class="line">    return arr[arr.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLast_(arr) &#123;</span><br><span class="line">    return arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var source = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var last = getLast(source); // 返回结果4 原数组不变</span><br><span class="line">var last_ = getLast_(source); // 返回结果4 原数据最后一项被删除</span><br></pre></td></tr></table></figure><p>getLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var source = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">source.slice(1, 3); // 纯函数 返回[2, 3] source不变</span><br><span class="line">source.splice(1, 3); // 不纯的 返回[2, 3, 4] source被改变</span><br><span class="line"></span><br><span class="line">source.pop(); // 不纯的</span><br><span class="line">source.push(6); // 不纯的</span><br><span class="line">source.shift(); // 不纯的</span><br><span class="line">source.unshift(1); // 不纯的</span><br><span class="line">source.reverse(); // 不纯的</span><br><span class="line"></span><br><span class="line">// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下</span><br><span class="line">source = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">source.concat([6, 7]); // 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变</span><br><span class="line">source.join(&apos;-&apos;); // 纯函数 返回1-2-3-4-5 source不变</span><br></pre></td></tr></table></figure><p><strong>闭包</strong></p><p>闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。</p>]]></content>
    
    <summary type="html">
    
      函数与函数式编程
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端基础测试</title>
    <link href="http://yoursite.com/2018/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/12/29/前端基础测试/</id>
    <published>2018-12-29T09:20:39.000Z</published>
    <updated>2018-12-29T09:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="文档流的理解"><a href="#文档流的理解" class="headerlink" title="文档流的理解"></a>文档流的理解</h2><p>将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流.(自己的理解是从头到尾按照文档的顺序，该在什么位置就在什么位置，也可以按照上面的意思理解，自上而下，自左到右的顺序)</p><p>下面为转自<a href="http://www.cnblogs.com/huangbx/archive/2012/08/15/2640734.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangbx/archive/2012/08/15/2640734.html</a></p><h3 id="一、定位的专业解释-来自百度百科"><a href="#一、定位的专业解释-来自百度百科" class="headerlink" title="一、定位的专业解释(来自百度百科)"></a>一、定位的专业解释(来自百度百科)</h3><p>在CSS中关于定位的内容是：position:relative | absolute | static | fixed</p><ul><li><p>static 没有特别的设定，遵循基本的定位规定，不能通过z-index进行层次分级。</p></li><li><p>relative 不脱离文档流，参考自身静态位置通过 top,bottom,left,right 定位，并且可以通过z-index进行层次分级。</p></li><li><p>absolute 脱离文档流，通过 top,bottom,left,right 定位。选取其最近的父级定位元素，当父级 position 为 static 时，absolute元素将以body坐标原点进行定位，可以通过z-index进行层次分级。</p></li><li><p>fixed 固定定位，这里他所固定的对像是可视窗口而并非是body或是父级元素。可通过z-index进行层次分级。</p></li></ul><p>CSS中定位的层叠分级：z-index: auto | namber;</p><ul><li><p>auto 遵从其父对象的定位</p></li><li><p>namber 无单位的整数值。可为负数</p></li></ul><p><strong>【注】什么是文档流：</strong></p><p>文档流是文档中可显示对象在排列时所占用的位置。比如网页的div标签它默认占用的宽度位置是一整行，p标签默认占用宽度也是一整行，因为div标签和p标签是块状对象。</p><h3 id="二、我的理解"><a href="#二、我的理解" class="headerlink" title="二、我的理解"></a>二、我的理解</h3><ul><li><p>static：以父级标签（用position限定）左上角为原点，根据top,left,right,bottom定死了，如果父级没有position限定，top、left等限定将不被浏览器解析（即无效）；并且在设计页面不能拖动。 </p></li><li><p>relative：设计的时候以文本流（即实际可用空间，只有static和relative会占有文本流）左上角为原点，可以拖动（不影响和父级标签的相对关系），页面缩放时跟随父级标签缩放（相对位置不变），由于文本流的关系，与父级标签存在间接的相对关系。</p></li><li><p>absolute：若父级标签用position的absolute和relative限定，设计的时候以父级标签左上角为原点；其它的（无position限定或者父级用static或者fixed限定的）则相对于body为标准；可以拖动；</p></li></ul><p>页面缩放时只在父级为positon中的absolute和relative限定的时候跟随父级标签（若没有，则以body为标准）缩放。</p><ul><li>fixed：相对于浏览器的可视窗口固定，在调整窗口的大小时，位置变化只与窗口有关。</li></ul><table><thead><tr><th></th><th>父级标签无position限定</th><th style="text-align:center">父级标签用static限定</th><th style="text-align:right">父级标签用fixed限定</th><th style="text-align:right">父级标签用absolute限定</th><th style="text-align:right">父级标签用relative限定 </th></tr></thead><tbody><tr><td>fixed</td><td>相对可视窗口</td><td style="text-align:center">相对可视窗口</td><td style="text-align:right">相对可视窗口</td><td style="text-align:right">相对可视窗口</td><td style="text-align:right">相对可视窗口 </td></tr><tr><td>absolute</td><td>相对body</td><td style="text-align:center">相对body</td><td style="text-align:right">相对body</td><td style="text-align:right">相对父级</td><td style="text-align:right">相对父级 </td></tr><tr><td>relative</td><td>相对文本流定位（与父级有间接关系）</td></tr><tr><td>static</td><td>相对父级定位top等限定无效</td><td style="text-align:center">相对父级定位top等限定无效</td><td style="text-align:right">相对父级定位top等限定无效</td><td style="text-align:right">相对父级定位top等限定无效</td><td style="text-align:right">相对父级定位top等限定无效 </td></tr></tbody></table><h2 id="定位方式有哪些，哪些脱离了文档流"><a href="#定位方式有哪些，哪些脱离了文档流" class="headerlink" title="定位方式有哪些，哪些脱离了文档流"></a>定位方式有哪些，哪些脱离了文档流</h2><ul><li>fixed 脱离文档流</li><li>absolute 脱离文档流</li><li>relative </li><li>static</li></ul><h2 id="清除浮动的原理是什么？如何解决高度坍塌"><a href="#清除浮动的原理是什么？如何解决高度坍塌" class="headerlink" title="清除浮动的原理是什么？如何解决高度坍塌"></a>清除浮动的原理是什么？如何解决高度坍塌</h2>]]></content>
    
    <summary type="html">
    
      面试宝典
    
    </summary>
    
    
      <category term="面试宝典" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>在chrome开发者工具中观察函数调用栈、作用域链与闭包</title>
    <link href="http://yoursite.com/2018/12/21/%E5%9C%A8chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%AD%E8%A7%82%E5%AF%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/12/21/在chrome开发者工具中观察函数调用栈、作用域链与闭包/</id>
    <published>2018-12-21T10:00:00.000Z</published>
    <updated>2018-12-21T12:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，有一个非常重要的技能，叫做<strong>断点调试</strong>。</p><p>在chrome的开发者工具中，通过断点调试，我们能够非常方便的一步一步的观察JavaScript的执行过程，直观感知函数调用栈，作用域链，变量对象，闭包，this等关键信息的变化。因此，断点调试对于快速定位代码错误，快速了解代码的执行过程有着非常重要的作用，这也是我们前端开发者必不可少的一个高级技能。</p><p>当然如果你对JavaScript的这些基础概念（执行上下文，变量对象，闭包，this等）了解还不够的话，想要透彻掌握断点调试可能会有一些困难。但是好在在前面几篇文章，我都对这些概念进行了详细的概述，因此要掌握这个技能，对大家来说，应该是比较轻松的。</p><p>这篇文章的主要目的在于借助对于断点调试的学习，来进一步加深对闭包的理解。</p><h5 id="一、基础概念回顾"><a href="#一、基础概念回顾" class="headerlink" title="一、基础概念回顾"></a>一、基础概念回顾</h5><p>函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致。</p><h5 id="二、认识断点调试工具"><a href="#二、认识断点调试工具" class="headerlink" title="二、认识断点调试工具"></a>二、认识断点调试工具</h5><p>在尽量新版本的chrome浏览器中（不确定你用的老版本与我的一致），调出chrome浏览器的开发者工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器右上角竖着的三点 -&gt; 更多工具 -&gt; 开发者工具 -&gt; Sources</span><br></pre></td></tr></table></figure><p>界面如图。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-4e9c80363ceda197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="断点调试界面"></p><p>在我的demo中，我把代码放在app.js中，在index.html中引入。我们暂时只需要关注截图中红色箭头的地方。在最右侧上方，有一排图标。我们可以通过使用他们来控制函数的执行顺序。从左到右他们依次是：</p><ul><li><p>resume/pause script execution<br>恢复/暂停脚本执行</p></li><li><p><strong>step over next function call</strong><br>跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。</p></li><li><p><strong>step into next function call</strong><br>跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。</p></li><li><p><strong>step out of current function</strong><br>跳出当前函数</p></li><li><p>deactivate breakpoints<br>停用断点</p></li><li><p>don‘t pause on exceptions<br>不暂停异常捕获</p></li></ul><p>其中跨过，跨入，跳出是我使用最多的三个操作。</p><p>上图右侧第二个红色箭头指向的是函数调用栈（call Stack），这里会显示代码执行过程中，调用栈的变化。</p><p>右侧第三个红色箭头指向的是作用域链（Scope），这里会显示当前函数的作用域链。其中Local表示当前的局部变量对象，Closure表示当前作用域链中的闭包。借助此处的作用域链展示，我们可以很直观的判断出一个例子中，到底谁是闭包，对于闭包的深入了解具有非常重要的帮助作用。</p><h5 id="三、断点设置"><a href="#三、断点设置" class="headerlink" title="三、断点设置"></a>三、断点设置</h5><p>在显示代码行数的地方点击，即可设置一个断点。断点设置有以下几个特点：</p><ul><li><p>在单独的变量声明(如果没有赋值)，函数声明的那一行，无法设置断点。</p></li><li><p>设置断点后刷新页面，JavaScript代码会执行到断点位置处暂停执行，然后我们就可以使用上边介绍过的几个操作开始调试了。</p></li><li><p>当你设置多个断点时，chrome工具会自动判断从最早执行的那个断点开始执行，因此我一般都是设置一个断点就行了。</p></li></ul><h5 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h5><p>接下来，我们借助一些实例，来使用断点调试工具，看一看，我们的demo函数，在执行过程中的具体表现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line"></span><br><span class="line">var fn;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function baz() &#123;</span><br><span class="line">        console.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    fn = baz;</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); // 2</span><br></pre></td></tr></table></figure><p>在向下阅读之前，我们可以停下来思考一下，这个例子中，谁是闭包？</p><p>这是来自《你不知道的js》中的一个例子。由于在使用断点调试过程中，发现chrome浏览器理解的闭包与该例子中所理解的闭包不太一致，因此专门挑出来，供大家参考。我个人更加倾向于chrome中的理解。</p><ul><li>第一步：设置断点，然后刷新页面。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13280589-03d44db694c69c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置断点"></p><ul><li>第二步：点击上图红色箭头指向的按钮（step into），该按钮的作用会根据代码执行顺序，一步一步向下执行。在点击的过程中，我们要注意观察下方call stack 与 scope的变化，以及函数执行位置的变化。</li></ul><p>一步一步执行，当函数执行到上例子中</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-262149745217c064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="baz函数被调用执行，foo形成了闭包"></p><p>我们可以看到，在chrome工具的理解中，由于在foo内部声明的baz函数在调用时访问了它的变量a，因此foo成为了闭包。这好像和我们学习到的知识不太一样。我们来看看在《你不知道的js》这本书中的例子中的理解。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-5baa2650d4d61987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="你不知道的js中的例子"></p><p>书中的注释可以明显的看出，作者认为fn为闭包。即baz，这和chrome工具中明显是不一样的。</p><p>而在备受大家推崇的《JavaScript高级编程》一书中，是这样定义闭包。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-293ce9a71af26c2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JavaScript高级编程中闭包的定义"></p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-8132e3f93f784584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="书中作者将自己理解的闭包与包含函数所区分"></p><p>这里chrome中理解的闭包，与我所阅读的这几本书中的理解的闭包不一样。其实在之前对于闭包分析的文章中，我已经有对这种情况做了一个解读。<a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">闭包详解</a></p><p>闭包是一个特殊对象，它由执行上下文(代号A)与在该执行上下文中创建的函数(代号B)共同组成。</p><p>当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。</p><p>那么在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。</p><p>我们修改一下demo01中的例子，来看看一个非常有意思的变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// demo02</span><br><span class="line">var fn;</span><br><span class="line">var m = 20;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function baz(a) &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = baz;</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    fn(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); // 20</span><br></pre></td></tr></table></figure><p>这个例子在demo01的基础上，我在baz函数中传入一个参数，并打印出来。在调用时，我将全局的变量m传入。输出结果变为20。在使用断点调试看看作用域链。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-3fedc1000518dbad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包没了，作用域链中没有包含foo了。"></p><p>是不是结果有点意外，闭包没了，作用域链中没有包含foo了。我靠，跟我们理解的好像又有点不一样。所以通过这个对比，我们可以确定闭包的形成需要两个条件。</p><ul><li>在函数内部创建新的函数；</li><li>新的函数在执行时，访问了函数的变量对象；</li></ul><p>还有更有意思的。</p><p>我们继续来看看一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// demo03</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line"></span><br><span class="line">    return function bar() &#123;</span><br><span class="line">        var b = 9;</span><br><span class="line"></span><br><span class="line">        return function fn() &#123;</span><br><span class="line">            console.log(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo();</span><br><span class="line">var fn = bar();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>在这个例子中，fn只访问了foo中的a变量，因此它的闭包只有foo。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-44176567bbf36725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包只有foo"></p><p>修改一下demo03，我们在fn中也访问bar中b变量试试看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// demo04</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line"></span><br><span class="line">    return function bar() &#123;</span><br><span class="line">        var b = 9;</span><br><span class="line"></span><br><span class="line">        return function fn() &#123;</span><br><span class="line">            console.log(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo();</span><br><span class="line">var fn = bar();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13280589-3fec03a98632e061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这个时候闭包变成了两个"></p><p>这个时候，闭包变成了两个。分别是bar，foo。</p><p>我们知道，闭包在模块中的应用非常重要。因此，我们来一个模块的例子，也用断点工具来观察一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// demo05</span><br><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">    var a = 10;</span><br><span class="line">    var b = 20;</span><br><span class="line"></span><br><span class="line">    var test = &#123;</span><br><span class="line">        m: 20,</span><br><span class="line">        add: function(x) &#123;</span><br><span class="line">            return a + x;</span><br><span class="line">        &#125;,</span><br><span class="line">        sum: function() &#123;</span><br><span class="line">            return a + b + this.m;</span><br><span class="line">        &#125;,</span><br><span class="line">        mark: function(k, j) &#123;</span><br><span class="line">            return k + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.test = test;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">test.add(100);</span><br><span class="line">test.sum();</span><br><span class="line">test.mark();</span><br><span class="line"></span><br><span class="line">var _mark = test.mark;</span><br><span class="line">_mark();</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13280589-d463fcb8494902d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add执行时，闭包为外层的自执行函数，this指向test"></p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-81e95abc541e301d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sum执行时，同上"></p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-fafa4a0121950298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mark执行时，闭包为外层的自执行函数，this指向test"></p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-c433ce5dfa47a832.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="_mark执行时，闭包为外层的自执行函数，this指向window"></p><blockquote><p>注意：这里的this指向显示为Object或者Window，大写开头，他们表示的是实例的构造函数，实际上this是指向的具体实例</p></blockquote><blockquote><p>test.mark能形成闭包，跟下面的补充例子（demo07）情况是一样的。</p></blockquote><p>我们还可以结合点断调试的方式，来理解那些困扰我们很久的this指向。随时观察this的指向，在实际开发调试中非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// demo06</span><br><span class="line"></span><br><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn () &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj); // 20</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13280589-5501e54b34f5b147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this指向obj"></p><p>最后继续补充一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// demo07</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 10;</span><br><span class="line"></span><br><span class="line">    function fn1() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fn2() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这个例子，和其他例子不太一样。虽然fn2并没有访问到foo的变量，但是foo执行时仍然变成了闭包。而当我将fn1的声明去掉时，闭包便不会出现了。</p><p>那么结合这个特殊的例子，我们可以这样这样定义闭包。</p><p><strong>闭包是指这样的作用域(foo)，它包含有一个函数(fn1)，这个函数(fn1)可以调用被这个作用域所封闭的变量(a)、函数、或者闭包等内容。通常我们通过闭包所对应的函数来获得对闭包的访问。</strong></p><p>更多的例子，大家可以自行尝试，总之，学会了使用断点调试之后，我们就能够很轻松的了解一段代码的执行过程了。这对快速定位错误，快速了解他人的代码都有非常巨大的帮助。大家一定要动手实践，把它给学会。</p><p>最后，根据以上的摸索情况，再次总结一下闭包：</p><ul><li><p>闭包是在函数被调用执行的时候才被确认创建的。</p></li><li><p>闭包的形成，与作用域链的访问顺序有直接关系。</p></li><li><p>只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      在chrome开发者工具中观察函数调用栈、作用域链与闭包
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>后台Api数据返回规范</title>
    <link href="http://yoursite.com/2018/12/17/%E5%90%8E%E5%8F%B0Api%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/17/后台Api数据返回规范/</id>
    <published>2018-12-17T10:00:00.000Z</published>
    <updated>2018-12-17T07:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="返回码"><a href="#返回码" class="headerlink" title="返回码"></a>返回码</h1><p>一般以 http response status code 作为返回码，参考 <a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">rfc7231</a></p><h3 id="请求成功"><a href="#请求成功" class="headerlink" title="请求成功"></a>请求成功</h3><ul><li>200 OK：请求成功</li><li>201 CREATED：成功处理请求，并且有新的资源被创建</li><li>202 Accepted：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT：成功处理请求，但没有任何数据返回</li></ul><h3 id="请求失败"><a href="#请求失败" class="headerlink" title="请求失败"></a>请求失败</h3><ul><li>400 INVALID REQUEST：用户发出的请求有错误，服务器没有进行处理</li><li>401 Unauthorized：表示用户没有权限（令牌、用户名、密码错误）</li><li>403 Forbidden：表示用户得到授权（与401错误相对），但是访问是被禁止的</li><li>404 NOT FOUND：找不到资源，因为资源不存在和路由不存在会有二义性，所以如果是资源不存在，我们当成业务逻辑错误来处理。比如用户不存在，会返回 499，并且会返回一个 error json object</li><li>422 Unprocesable Entity：请求的参数发生一个验证错误</li><li>499 业务逻辑错误，说明见下面</li><li>500 INTERNAL SERVER ERROR：服务器发生错误，用户将无法判断发出的请求是否成功<h4 id="请求失败返回的数据格式"><a href="#请求失败返回的数据格式" class="headerlink" title="请求失败返回的数据格式"></a>请求失败返回的数据格式</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"手机 不存在。"</span>,</span><br><span class="line">    <span class="attr">"status_code"</span>: <span class="number">422</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="业务逻辑错误"><a href="#业务逻辑错误" class="headerlink" title="业务逻辑错误"></a>业务逻辑错误</h3><p><strong>如果是业务逻辑错误，http response status code 会返回 499，同时会有一个 error json object 返回</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: &#123;</span><br><span class="line">        <span class="attr">"code"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"user_message"</span>: <span class="string">"暂未开放账号注册"</span>,</span><br><span class="line">        <span class="attr">"internal_message"</span>: <span class="string">"暂未开放账号注册"</span>,</span><br><span class="line">        <span class="attr">"more_info"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>code: 不同的场景返回不同的值，客户端可根据这个值做不同的业务逻辑处理<br>user_message: 显示给用户看的错误信息（一般可以弹一个 toast），为空字符串时，不显示</p><p><strong>特殊情况：如果给阿里云 OSS 的回调返回 4xx 错误时，阿里云会给客户端返回错误，客户端拿不到 error 信息。所以阿里云 OSS 的回调需要特殊处理，后台会返回 299 。</strong></p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>比如获取医生详情<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"hospital"</span>: <span class="string">"速眠睡眠中心"</span>,</span><br><span class="line">    <span class="attr">"department"</span>: <span class="string">"睡眠科"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"主任医师"</span>,</span><br><span class="line">    <span class="attr">"qr_code_raw"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"introduction"</span>: <span class="string">"速眠睡眠中心主任医生。主要临床专业特长： 各种精神与心理障碍诊疗，尤其是难治性焦虑、抑郁和睡眠障碍的临床诊断和药物治疗。"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"速眠医生"</span>,</span><br><span class="line">    <span class="attr">"avatar"</span>: <span class="string">"https://sleep-doctor.oss-cn-shenzhen.aliyuncs.com/doctors/avatar/1/93cb9585-fcf3-4888-aed8-678d3a873232.jpg"</span>,</span><br><span class="line">    <span class="attr">"introduction_no_tag"</span>: <span class="string">"速眠睡眠中心主任医生。主要临床专业特长： 各种精神与心理障碍诊疗，尤其是难治性焦虑、抑郁和睡眠障碍的临床诊断和药物治疗。"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分页列表"><a href="#分页列表" class="headerlink" title="分页列表"></a>分页列表</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"8c50ea3a-265c-4d64-b181-03659ffe78e6"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"App\\Notifications\\ScaleDistribution"</span>,</span><br><span class="line">            <span class="attr">"read_at"</span>: <span class="number">1527638152</span>,</span><br><span class="line">            <span class="attr">"created_at"</span>: <span class="number">1527603221</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"38cfa914-78e0-447a-be19-da5f03d5aa56"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"App\\Notifications\\ScaleDistribution"</span>,</span><br><span class="line">            <span class="attr">"read_at"</span>: <span class="number">1527638148</span>,</span><br><span class="line">            <span class="attr">"created_at"</span>: <span class="number">1527603114</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">            <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"count"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"per_page"</span>: <span class="number">15</span>,</span><br><span class="line">            <span class="attr">"current_page"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"total_pages"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"links"</span>: &#123;</span><br><span class="line">                <span class="attr">"previous"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"next"</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data: 数据列表，数组类型<br>meta: 元信息<br>meta.pagination 分页信息<br>meta.pagination.total 总数量<br>meta.pagination.count 当前页数量<br>meta.pagination.per_page 每页数量<br>meta.pagination.current_page 当前页码<br>meta.pagination.total_pages 总页数<br>meta.pagination.links 链接<br>meta.pagination.links.next 下一页的链接</p><h1 id="include-使用说明"><a href="#include-使用说明" class="headerlink" title="include 使用说明"></a>include 使用说明</h1><p>如果 api 文档有写可以使用 include 参数，如下：</p><p><img src="/tfl/captures/2018-06/tapd_21177101_base64_1529562968_14.png" alt="图片描述"></p><p>则可以根据需要来设置 include 的值。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="advisories-26"><a href="#advisories-26" class="headerlink" title="/advisories/26"></a>/advisories/26</h3><p><strong>只有 advisory 的数据</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"package_id"</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="attr">"order_id"</span>: <span class="number">191</span>,</span><br><span class="line">    <span class="attr">"user_id"</span>: <span class="number">2002</span>,</span><br><span class="line">    <span class="attr">"doctor_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"start_at"</span>: <span class="number">1526526520</span>,</span><br><span class="line">    <span class="attr">"end_at"</span>: <span class="number">1526612920</span>,</span><br><span class="line">    <span class="attr">"created_at"</span>: <span class="number">1526526501</span>,</span><br><span class="line">    <span class="attr">"updated_at"</span>: <span class="number">1526612920</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"咯过哦了也在咯做最住\r\n莫咯咯哦了也扣我\r\n李金龙\r\n来PK困咯\r\nKKK女弄\r\n萝莉控\r\n你咯搜狗"</span>,</span><br><span class="line">    <span class="attr">"service_id"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"remind_description"</span>: <span class="string">"服务已关闭，款项会退回原账户"</span>,</span><br><span class="line">    <span class="attr">"last_count"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="advisories-26-include-user"><a href="#advisories-26-include-user" class="headerlink" title="/advisories/26?include=user"></a>/advisories/26?include=user</h3><p><strong>有 advisory 和 user 的数据</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"package_id"</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="attr">"order_id"</span>: <span class="number">191</span>,</span><br><span class="line">    <span class="attr">"user_id"</span>: <span class="number">2002</span>,</span><br><span class="line">    <span class="attr">"doctor_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"start_at"</span>: <span class="number">1526526520</span>,</span><br><span class="line">    <span class="attr">"end_at"</span>: <span class="number">1526612920</span>,</span><br><span class="line">    <span class="attr">"created_at"</span>: <span class="number">1526526501</span>,</span><br><span class="line">    <span class="attr">"updated_at"</span>: <span class="number">1526612920</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"咯过哦了也在咯做最住\r\n莫咯咯哦了也扣我\r\n李金龙\r\n来PK困咯\r\nKKK女弄\r\n萝莉控\r\n你咯搜狗"</span>,</span><br><span class="line">    <span class="attr">"service_id"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"remind_description"</span>: <span class="string">"服务已关闭，款项会退回原账户"</span>,</span><br><span class="line">    <span class="attr">"last_count"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">2002</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"15118132143"</span>,</span><br><span class="line">        <span class="attr">"nickname"</span>: <span class="string">"LDL"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"李德林"</span>,</span><br><span class="line">        <span class="attr">"avatar"</span>: <span class="string">"https://sleep-doctor.oss-cn-shenzhen.aliyuncs.com/avatar/3/8277ef5a-d0f7-4467-85d5-acb37574cbe2.jpg"</span>,</span><br><span class="line">        <span class="attr">"area"</span>: <span class="string">"未设置"</span>,</span><br><span class="line">        <span class="attr">"monitor_sn"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"sleeper_sn"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"career"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"created_at"</span>: <span class="number">1517829357</span>,</span><br><span class="line">        <span class="attr">"updated_at"</span>: <span class="number">1528094307</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="advisories-26-include-user-doctor"><a href="#advisories-26-include-user-doctor" class="headerlink" title="/advisories/26?include=user,doctor"></a>/advisories/26?include=user,doctor</h3><p><strong>有 advisory，user 和 doctor 的数据</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"package_id"</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="attr">"order_id"</span>: <span class="number">191</span>,</span><br><span class="line">    <span class="attr">"user_id"</span>: <span class="number">2002</span>,</span><br><span class="line">    <span class="attr">"doctor_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"start_at"</span>: <span class="number">1526526520</span>,</span><br><span class="line">    <span class="attr">"end_at"</span>: <span class="number">1526612920</span>,</span><br><span class="line">    <span class="attr">"created_at"</span>: <span class="number">1526526501</span>,</span><br><span class="line">    <span class="attr">"updated_at"</span>: <span class="number">1526612920</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"咯过哦了也在咯做最住\r\n莫咯咯哦了也扣我\r\n李金龙\r\n来PK困咯\r\nKKK女弄\r\n萝莉控\r\n你咯搜狗"</span>,</span><br><span class="line">    <span class="attr">"service_id"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"remind_description"</span>: <span class="string">"服务已关闭，款项会退回原账户"</span>,</span><br><span class="line">    <span class="attr">"last_count"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">2002</span>,</span><br><span class="line">        <span class="attr">"mobile"</span>: <span class="string">"15118132143"</span>,</span><br><span class="line">        <span class="attr">"nickname"</span>: <span class="string">"LDL"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"李德林"</span>,</span><br><span class="line">        <span class="attr">"avatar"</span>: <span class="string">"https://sleep-doctor.oss-cn-shenzhen.aliyuncs.com/avatar/3/8277ef5a-d0f7-4467-85d5-acb37574cbe2.jpg"</span>,</span><br><span class="line">        <span class="attr">"area"</span>: <span class="string">"未设置"</span>,</span><br><span class="line">        <span class="attr">"monitor_sn"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"sleeper_sn"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"career"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"created_at"</span>: <span class="number">1517829357</span>,</span><br><span class="line">        <span class="attr">"updated_at"</span>: <span class="number">1528094307</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"doctor"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"hospital"</span>: <span class="string">"速眠睡眠中心"</span>,</span><br><span class="line">        <span class="attr">"department"</span>: <span class="string">"睡眠科"</span>,</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"主任医师"</span>,</span><br><span class="line">        <span class="attr">"qr_code_raw"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"introduction"</span>: <span class="string">"速眠睡眠中心主任医生。主要临床专业特长： 各种精神与心理障碍诊疗，尤其是难治性焦虑、抑郁和睡眠障碍的临床诊断和药物治疗。"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"速眠医生"</span>,</span><br><span class="line">        <span class="attr">"avatar"</span>: <span class="string">"https://sleep-doctor.oss-cn-shenzhen.aliyuncs.com/doctors/avatar/1/93cb9585-fcf3-4888-aed8-678d3a873232.jpg"</span>,</span><br><span class="line">        <span class="attr">"introduction_no_tag"</span>: <span class="string">"速眠睡眠中心主任医生。主要临床专业特长： 各种精神与心理障碍诊疗，尤其是难治性焦虑、抑郁和睡眠障碍的临床诊断和药物治疗。"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="token-自动刷新机制"><a href="#token-自动刷新机制" class="headerlink" title="token 自动刷新机制"></a>token 自动刷新机制</h1><p>token 如果已经过期，但在可刷新有效期内，服务器会自动生成一个新的 token，并且在当前请求的 response header 返回，<br>格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &#123;newToken&#125;</span><br></pre></td></tr></table></figure><br>客户端要检查每个请求的 response header 是否有 Authorization，如果有，要把 {newToken} 保存下来并用新的 token 来请求。<br>重新生成 token 后，旧 token 还可以用 60 秒，所以客户端不用处理并发的问题。</p>]]></content>
    
    <summary type="html">
    
      后台Api数据返回规范.md
    
    </summary>
    
      <category term="后台" scheme="http://yoursite.com/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="后台" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>commit代码规范</title>
    <link href="http://yoursite.com/2018/12/17/commit%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/17/commit代码规范/</id>
    <published>2018-12-17T05:32:39.000Z</published>
    <updated>2018-12-17T07:14:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本样式：</p><pre><code>[type] [module] : --bug=1000627 Message//空一行detail//空一行</code></pre><hr><p>type, module 和 message 是必选。detail 为可选。</p><ul><li><p>type 用于说明 commit 的类别，使用下面标识：</p><ol><li>bug-fix：修复bug</li><li>feature：新功能实现</li><li>optimize：重构，优化，工程配置等</li><li>merge:  用于替换自动生成合并分支log</li></ol></li><li><p>module 用于说明commit内容所属的业务模块（如果不属于任何模块，使用“通用”）</p></li><li>detail 用于在该commit内容不单一的时候，加以说明</li><li>针对bug-fix 和 feature需要添加关键字： –bug=bugid –story=storyid</li></ul><hr><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>===<br>[fixbug] [咨询]  : 修复会话页面在iOS10上显示异常的问题</p><p>===<br>[fixbug] [咨询] [tapd id: 1009080,1090900] : 修复以下bug：</p><p>1.修复会话页面在iOS10上显示异常的问题<br>2.修复tabbarItem小红点显示逻辑不正确bug<br>3.修复navigationbar高度不正确的问题</p><p>===<br>[feature] [登陆]  : 导入微信SDK，实现微信登陆</p><p>===<br>[optimize] [工程配置] : 增加会话创建失败后的重连，降低失败概率</p><p>===<br>[merge] :  Merge branch ‘releaseV0.2.0’ into ‘develop’</p>]]></content>
    
    <summary type="html">
    
      commit代码规范
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>全方位解读this</title>
    <link href="http://yoursite.com/2018/12/16/%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BBthis/"/>
    <id>http://yoursite.com/2018/12/16/全方位解读this/</id>
    <published>2018-12-16T10:00:00.000Z</published>
    <updated>2018-12-16T14:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。</p><p>危害比较大的是，有的不准确的结论在网上还广为流传。</p><p>比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我是非常相信这句话的。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。其实只是因为我心中有一个不太准确的结论。</p><p>所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。</p><p>在这之前，我们需要来回顾一下执行上下文。</p><p>在前面几篇文章中，我有好几个地方都提到执行上下文的生命周期，为了防止大家没有记住，再次来回顾一下，如下图。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-fb87f7d9cc723938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行上下文生命周期"></p><p>在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。</p><p>首先我们需要得出一个非常重要一定要牢记于心的结论，<strong>this的指向，是在函数被调用的时候确定的。</strong>也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn () &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); // 10</span><br><span class="line">fn.call(obj); // 20</span><br></pre></td></tr></table></figure><p>除此之外，<strong>在函数执行过程中，this一旦被确定，就不可更改了。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn () &#123;</span><br><span class="line">    this = obj; // 这句话试图修改this，运行后会报错</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p><strong> 一、全局对象中的this </strong></p><p>关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 通过this绑定到全局对象</span><br><span class="line">this.a2 = 20;</span><br><span class="line"></span><br><span class="line">// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span><br><span class="line">var a1 = 10;</span><br><span class="line"></span><br><span class="line">// 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span><br><span class="line">a3 = 30;</span><br><span class="line"></span><br><span class="line">// 输出结果会全部符合预期</span><br><span class="line">console.log(a1);</span><br><span class="line">console.log(a2);</span><br><span class="line">console.log(a3);</span><br></pre></td></tr></table></figure><h5 id="二、函数中的this"><a href="#二、函数中的this" class="headerlink" title="二、函数中的this"></a>二、函数中的this</h5><p>在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line">var a = 20;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// demo02</span><br><span class="line">var a = 20;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// demo03</span><br><span class="line">var a = 20;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    c: this.a + 20,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj.c);</span><br><span class="line">console.log(obj.fn());</span><br></pre></td></tr></table></figure><p>这几个例子需要花点时间仔细感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。</p><p>分析之前，我们先直接了当抛出结论。</p><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。<strong>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined</strong>。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p><p>从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局</span><br><span class="line">function fn() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  // fn是调用者，独立调用</span><br><span class="line">window.fn();  // fn是调用者，被window所拥有</span><br></pre></td></tr></table></figure><p>在上面的简单例子中，<code>fn()</code>作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而<code>window.fn()</code>则因为fn被window所拥有，内部的this就指向了window对象。</p><p>那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。</p><p>但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用<code>this.a + 20</code>来计算。这里我们需要明确的一点是，单独的<code>{}</code>是不会形成新的作用域的，因此这里的<code>this.a</code>，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。</p><p>那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var a = 20;</span><br><span class="line">function foo () &#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        a: 10,</span><br><span class="line">        c: this.a + 20,</span><br><span class="line">        fn: function () &#123;</span><br><span class="line">            return this.a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj.c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(foo());    // ？</span><br><span class="line">console.log(window.foo());  // ?</span><br></pre></td></tr></table></figure><blockquote><ul><li>实际开发中，并不推荐这样使用this；</li><li>上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。</li></ul></blockquote><p>再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var foo = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    getA: function () &#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.getA()); // 10</span><br><span class="line"></span><br><span class="line">var test = foo.getA;</span><br><span class="line">console.log(test());  // 20</span><br></pre></td></tr></table></figure><p><code>foo.getA()</code>中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而<code>test()</code>作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p><p>稍微修改一下代码，大家自行理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">function getA() &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line">var foo = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    getA: getA</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.getA());  // 10</span><br></pre></td></tr></table></figure><p>灵机一动，再来一个。如下例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function active(fn) &#123;</span><br><span class="line">    fn(); // 真实调用者，为独立调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 20;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    getA: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">active(obj.getA);</span><br></pre></td></tr></table></figure><h5 id="三、使用call，apply显示指定this"><a href="#三、使用call，apply显示指定this" class="headerlink" title="三、使用call，apply显示指定this"></a>三、使用call，apply显示指定this</h5><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p><p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj);</span><br></pre></td></tr></table></figure><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(num1, num2) &#123;</span><br><span class="line">    console.log(this.a + num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj, 100, 10); // 130</span><br><span class="line">fn.apply(obj, [20, 10]); // 50</span><br></pre></td></tr></table></figure><p>因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。</p><ul><li>将类数组对象转换为数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function exam(a, b, c, d, e) &#123;</span><br><span class="line"></span><br><span class="line">    // 先看看函数的自带属性 arguments 什么是样子的</span><br><span class="line">    console.log(arguments);</span><br><span class="line"></span><br><span class="line">    // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变</span><br><span class="line">    var arg = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exam(2, 8, 9, 10, 3);</span><br><span class="line"></span><br><span class="line">// result:</span><br><span class="line">// &#123; &apos;0&apos;: 2, &apos;1&apos;: 8, &apos;2&apos;: 9, &apos;3&apos;: 10, &apos;4&apos;: 3 &#125;</span><br><span class="line">// [ 2, 8, 9, 10, 3 ]</span><br><span class="line">//</span><br><span class="line">// 也常常使用该方法将DOM中的nodelist转换为数组</span><br><span class="line">// [].slice.call( document.getElementsByTagName(&apos;li&apos;) );</span><br></pre></td></tr></table></figure><ul><li>根据自己的需要灵活修改this指向</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    name: &apos;joker&apos;,</span><br><span class="line">    showName: function() &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var bar = &#123;</span><br><span class="line">    name: &apos;rose&apos;</span><br><span class="line">&#125;</span><br><span class="line">foo.showName.call(bar);</span><br></pre></td></tr></table></figure><ul><li>实现继承</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 定义父级的构造函数</span><br><span class="line">var Person = function(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age  = age;</span><br><span class="line">    this.gender = [&apos;man&apos;, &apos;woman&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义子类的构造函数</span><br><span class="line">var Student = function(name, age, high) &#123;</span><br><span class="line"></span><br><span class="line">    // use call</span><br><span class="line">    Person.call(this, name, age);</span><br><span class="line">    this.high = high;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message = function() &#123;</span><br><span class="line">    console.log(&apos;name:&apos;+this.name+&apos;, age:&apos;+this.age+&apos;, high:&apos;+this.high+&apos;, gender:&apos;+this.gender[0]+&apos;;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Student(&apos;xiaom&apos;, 12, &apos;150cm&apos;).message();</span><br><span class="line"></span><br><span class="line">// result</span><br><span class="line">// ----------</span><br><span class="line">// name:xiaom, age:12, high:150cm, gender:man;</span><br></pre></td></tr></table></figure><p>简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Student = function(name, age, high) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age  = age;</span><br><span class="line">    this.gender = [&apos;man&apos;, &apos;woman&apos;];</span><br><span class="line">    // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承</span><br><span class="line">    this.high = high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在向其他执行上下文的传递中，确保this的指向保持不变</li></ul><p>如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    getA: function() &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(this.a)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><p>常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    getA: function() &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(self.a)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外就是借助闭包与apply方法，封装一个bind方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(obj, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    getA: function() &#123;</span><br><span class="line">        setTimeout(bind(function() &#123;</span><br><span class="line">            console.log(this.a)</span><br><span class="line">        &#125;, this), 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><p>当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 20,</span><br><span class="line">    getA: function() &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(this.a)</span><br><span class="line">        &#125;.bind(this), 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="四、构造函数与原型方法上的this"><a href="#四、构造函数与原型方法上的this" class="headerlink" title="四、构造函数与原型方法上的this"></a>四、构造函数与原型方法上的this</h5><p>在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。</p><p>结合下面的例子，我在例子抛出几个问题大家思考一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    // 这里的this指向了谁?</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line"></span><br><span class="line">    // 这里的this又指向了谁？</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面的2个this，是同一个吗，他们是否指向了原型对象？</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;Nick&apos;, 20);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure><p>我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。</p><p>通过new操作符调用构造函数，会经历以下4个阶段。</p><ul><li>创建一个新的对象；</li><li>将构造函数的this指向这个新对象；</li><li>指向构造函数的代码，为这个对象添加属性，方法等；</li><li>返回新对象。</li></ul><p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。</p><p>而原型方法上的this就好理解多了，根据上边对函数中this的定义，<code>p1.getName()</code>中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。</p>]]></content>
    
    <summary type="html">
    
      全方位解读this
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>详细图解作用域链与闭包</title>
    <link href="http://yoursite.com/2018/12/09/%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/12/09/详细图解作用域链与闭包/</id>
    <published>2018-12-09T10:00:00.000Z</published>
    <updated>2018-12-09T17:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13280589-3e4922fd7fd21dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="攻克闭包难题"></p><ul><li>攻克闭包难题</li></ul><p>初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。</p><p>闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，<strong>前端面试，必问闭包</strong>。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。</p><p>可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视[捂脸]。</p><p>因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者朋友们看了之后，就把闭包给彻底学会了，而不是似懂非懂。</p><h5 id="一、作用域与作用域链"><a href="#一、作用域与作用域链" class="headerlink" title="一、作用域与作用域链"></a>一、作用域与作用域链</h5><p>在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。</p><ul><li>基础数据类型与引用数据类型</li><li>内存空间</li><li>垃圾回收机制</li><li>执行上下文</li><li>变量对象与活动对象</li></ul><p>如果你暂时还没有明白，可以去看本系列的前三篇文章。为了讲解闭包，已经为大家做好了基础知识的铺垫哦。</p><p><strong>作用域</strong></p><ul><li>在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</li></ul><blockquote><p>这里的标识符，指的是变量名或者函数名</p></blockquote><ul><li><p>JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。</p></li><li><p>作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。</p></li></ul><blockquote><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13280589-4591d88f0b001127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程"></p><p><strong>作用域链</strong></p><p>回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-1b4a7b047d2ee885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行上下文生命周期"></p><p>我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。</p><p><strong>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</strong></p><p>为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    var b = a + 10;</span><br><span class="line"></span><br><span class="line">    function innerTest() &#123;</span><br><span class="line">        var c = 10;</span><br><span class="line">        return b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return innerTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innerTestEC = &#123;</span><br><span class="line">    VO: &#123;...&#125;,  // 变量对象</span><br><span class="line">    scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p><p>很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-741fce7b892fc62b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域链图示"></p><ul><li>作用域链图示</li></ul><blockquote><p>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object</p></blockquote><p>是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。</p><h5 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h5><p>对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。</p><p><strong>闭包是一种特殊的对象。</strong></p><p><strong>它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。</strong></p><p><strong>当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。</strong></p><p><strong>在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包。</strong></p><p>因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 20;</span><br><span class="line">    var b = 30;</span><br><span class="line"></span><br><span class="line">    function bar() &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。</p><p>在<a href="https://minmonster.github.io/2018/11/18/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4-%E5%A0%86%E6%A0%88%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">基础进阶（一）</a>中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。</p><p>而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。</p><p>先来一个简单的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fn = null;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function innnerFoo() &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    fn(); // 此处的保留的innerFoo的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); // 2</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>foo()</code>执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过<code>fn = innerFoo</code>，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。</p><p>这样，我们就可以称foo为闭包。</p><p>下图展示了闭包foo的作用域链。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-7a15a361b75949b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包foo的作用域链，图中标题写错了，请无视"></p><ul><li>闭包foo的作用域链，图中标题写错了，请无视</li></ul><p>我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。</p><blockquote><p>关于如何在chrome中观察闭包，以及更多闭包的例子，请阅读基础系列（六）</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13280589-79b2abb99e0b4a8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的innerFoo"></p><ul><li>从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的innerFoo</li></ul><p>在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。</p><p><strong>所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。</strong>比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。</p><p>不过读者朋友们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。</p><p>对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn = null;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function innnerFoo() &#123;</span><br><span class="line">        console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var c = 100;</span><br><span class="line">    fn(); // 此处的保留的innerFoo的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>关于这一点，很多同学把函数调用栈与作用域链没有分清楚，所以有的大神看了我关于介绍执行上下文的文章时就义正言辞的说我的例子有问题，而这些评论有很大的误导作用，为了帮助大家自己拥有能够辨别的能力，所以我写了基础（六），教大家如何在chrome中观察闭包，作用域链，this等。当然我也不敢100%保证我文中的例子就一定正确，所以教大家如何去辨认我认为才是最重要的。</p></blockquote><p><strong>闭包的应用场景</strong></p><p>除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。</p><ul><li>柯里化</li></ul><p>在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。<a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">点击了解更多关于柯里化的知识</a></p><ul><li>模块</li></ul><p>在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var a = 10;</span><br><span class="line">    var b = 20;</span><br><span class="line"></span><br><span class="line">    function add(num1, num2) &#123;</span><br><span class="line">        var num1 = !!num1 ? num1 : a;</span><br><span class="line">        var num2 = !!num2 ? num2 : b;</span><br><span class="line"></span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.add = add;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">add(10, 20);</span><br></pre></td></tr></table></figure><p>在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-f3810f99469a2714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数"></p><ul><li>此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数</li></ul><p>为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。</p><p>利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123;</span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/9b4a54a98660" target="_blank" rel="noopener">点此查看关于此题的详细解读</a></p><p>关于作用域链的与闭包我就总结完了，虽然我自认为我是说得非常清晰了，但是我知道理解闭包并不是一件简单的事情，所以如果你有什么问题，可以在评论中问我。你也可以带着从别的地方没有看懂的例子在评论中留言。大家一起学习进步。</p>]]></content>
    
    <summary type="html">
    
      JS 作用域链 闭包
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>变量对象详解</title>
    <link href="http://yoursite.com/2018/12/02/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/02/变量对象详解/</id>
    <published>2018-12-02T10:00:00.000Z</published>
    <updated>2018-12-02T12:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13280589-818e338f256b2d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。<br>在上一篇文章中，我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。</p><ul><li>创建阶段<br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</li><li>代码执行阶段<br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13280589-d33a07dc1667c4af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行上下文生命周期"></p><p>从这里我们就可以看出详细了解执行上下文极为重要，因为其中涉及到了变量对象，作用域链，this等很多人没有怎么弄明白，但是却极为重要的概念，它关系到我们能不能真正理解JavaScript。在后面的文章中我们会一一详细总结，这里我们先重点了解变量对象。</p><h5 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h5><p>变量对象的创建，依次经历了以下几个过程。</p><ol><li><p>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</p></li><li><p>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</p></li><li><p>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</p></li></ol><p>许多读者在阅读到这的时候会因为下面的这样场景对于“跳过”一词产生疑问。既然变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123; console.log(&apos;function foo&apos;) &#125;</span><br><span class="line">var foo = 20;</span><br><span class="line"></span><br><span class="line">console.log(foo); // 20</span><br></pre></td></tr></table></figure><p>其实只是大家在阅读的时候不够仔细，因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而<code>foo = 20</code>是在执行上下文的执行过程中运行的，输出结果自然会是20。对比下例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); // function foo</span><br><span class="line">function foo() &#123; console.log(&apos;function foo&apos;) &#125;</span><br><span class="line">var foo = 20;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 上栗的执行顺序为</span><br><span class="line"></span><br><span class="line">// 首先将所有函数声明放入变量对象中</span><br><span class="line">function foo() &#123; console.log(&apos;function foo&apos;) &#125;</span><br><span class="line"></span><br><span class="line">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值</span><br><span class="line">// var foo = undefined;</span><br><span class="line"></span><br><span class="line">// 然后开始执行阶段代码的执行</span><br><span class="line">console.log(foo); // function foo</span><br><span class="line">foo = 20;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/13280589-d946cb161fc91b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我知道有的人不喜欢看文字"></p><p>根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。</p><p>在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line"></span><br><span class="line">    var a = 1;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行<code>test()</code>时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建过程</span><br><span class="line">testEC = &#123;</span><br><span class="line">    // 变量对象</span><br><span class="line">    VO: &#123;&#125;,</span><br><span class="line">    scopeChain: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明</span><br><span class="line"></span><br><span class="line">// VO 为 Variable Object的缩写，即变量对象</span><br><span class="line">VO = &#123;</span><br><span class="line">    arguments: &#123;...&#125;,  //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span><br><span class="line">    foo: &lt;foo reference&gt;  // 表示foo的地址引用</span><br><span class="line">    a: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p><blockquote><p>这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 执行阶段</span><br><span class="line">VO -&gt;  AO   // Active Object</span><br><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &lt;foo reference&gt;,</span><br><span class="line">    a: 1,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，上面的例子demo1，执行顺序就变成了这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    var a;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line">    a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>再来一个例子，巩固一下我们的理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// demo2</span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    console.log(bar);</span><br><span class="line"></span><br><span class="line">    var foo = &apos;Hello&apos;;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    var bar = function () &#123;</span><br><span class="line">        return &apos;world&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return &apos;hello&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建阶段</span><br><span class="line">VO = &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &lt;foo reference&gt;,</span><br><span class="line">    bar: undefined</span><br><span class="line">&#125;</span><br><span class="line">// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 执行阶段</span><br><span class="line">VO -&gt; AO</span><br><span class="line">VO = &#123;</span><br><span class="line">    arguments: &#123;...&#125;,</span><br><span class="line">    foo: &apos;Hello&apos;,</span><br><span class="line">    bar: &lt;bar reference&gt;,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。</p><h5 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h5><p>以浏览器中为例，全局对象为window。<br>全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以浏览器中为例，全局对象为window</span><br><span class="line">// 全局上下文</span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,</span><br><span class="line">    this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p>]]></content>
    
    <summary type="html">
    
      变量对象详解
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>执行上下文详细图解</title>
    <link href="http://yoursite.com/2018/11/25/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/25/执行上下文详细图解/</id>
    <published>2018-11-25T10:00:00.000Z</published>
    <updated>2018-11-25T16:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13280589-5f75bbf6548f9dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="先随便放张图"><br><strong>_ 先随便放张图 _</strong></p><hr><p>我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 这里会打印出什么？</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念<strong>执行上下文（Execution Context）</strong>。</p><p>每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。</p><ul><li>全局环境：JavaScript代码运行起来会首先进入该环境</li><li>函数环境：当函数被调用执行时，会进入当前函数中执行代码</li><li>eval（不建议使用，可忽略）</li></ul><p>因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p><p>当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。</p><blockquote><p>执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-614bf915de60a26f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一步：全局上下文入栈"><br><strong>_ 第一步：全局上下文入栈 _</strong></p><hr><p>全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了<strong>changeColor()</strong>，这一句激活函数changeColor创建它自己的执行上下文，因此第二步就是<strong>changeColor</strong>的执行上下文入栈。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-77e0c092ca77104e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二步：changeColor的执行上下文入栈"><br><strong>_ 第二步：changeColor的执行上下文入栈 _</strong></p><hr><p><strong>changeColor</strong>的上下文入栈之后，控制器开始执行其中的可执行代码，遇到<strong>swapColors()</strong>之后又激活了一个执行上下文。因此第三步是<strong>swapColors</strong>的执行上下文入栈。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-fdca3df3c9a4a19e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三步：swapColors的执行上下文入栈"><br><strong>_ 第三步：swapColors的执行上下文入栈 _</strong></p><hr><p>在<strong>swapColors</strong>的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，<strong>swapColors</strong>的上下文从栈中弹出。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-d14f43009c394175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第四步：swapColors的执行上下文出栈"><br><strong>_ 第四步：swapColors的执行上下文出栈 _</strong></p><hr><p>swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-4570d9619bf6f3a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第五步：changeColor的执行上下文出栈"><br><strong>_ 第五步：changeColor的执行上下文出栈 _</strong></p><hr><p>全局上下文在浏览器窗口关闭后出栈。</p><blockquote><p>注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/13280589-ad66d2e91a005299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个过程"><br><strong>_ 整个过程 _</strong></p><hr><p>详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。</p><ul><li>单线程</li><li>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li><li>函数的执行上下文的个数没有限制</li><li>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li></ul><p>为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    var n=999;</span><br><span class="line">    function f2()&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure><p>因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/13280589-3075b78c5bf06087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例演变过程"><br><strong>_ 上例演变过程 _</strong></p><hr><p>最后留一个简单的例子，大家可以自己脑补一下这个例子在执行过程中执行上下文的变化情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  name: <span class="string">'Perter'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用变量保存的方式保证其访问的是p对象</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = p.getName();</span><br><span class="line"><span class="keyword">var</span> _name = getName();</span><br><span class="line"><span class="built_in">console</span>.log(_name);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JS 上下文
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
</feed>
