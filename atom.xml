<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bling</title>
  
  <subtitle>Monster&#39;s bling</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-23T15:39:20.023Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Monster</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NodeJS 读书笔记 第2章</title>
    <link href="http://yoursite.com/2018/06/23/NodeJS%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E7%AC%AC2%E7%AB%A0/"/>
    <id>http://yoursite.com/2018/06/23/NodeJS 读书笔记 第2章/</id>
    <published>2018-06-23T10:00:00.000Z</published>
    <updated>2018-06-23T15:39:20.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><h2 id="Node-js模块的实现"><a href="#Node-js模块的实现" class="headerlink" title="Node.js模块的实现"></a>Node.js模块的实现</h2><p>之前在网上查阅了许多介绍Node.js的文章，可惜对于Node.js的模块机制大都着墨不多。在后续介绍模块的使用之前，我认为有必要深入一下Node.js的模块机制。</p><h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>早在Netscape诞生不久后，JavaScript就一直在探索本地编程的路，Rhino是其代表产物。无奈那时服务端JavaScript走的路均是参考众多服务器端语言来实现的，在这样的背景之下，一没有特色，二没有实用价值。但是随着JavaScript在前端的应用越来越广泛，以及服务端JavaScript的推动，JavaScript现有的规范十分薄弱，不利于JavaScript大规模的应用。那些以JavaScript为宿主语言的环境中，只有本身的基础原生对象和类型，更多的对象和API都取决于宿主的提供，所以，我们可以看到JavaScript缺少这些功能：</p><ul><li>JavaScript没有模块系统。没有原生的支持密闭作用域或依赖管理。</li><li>JavaScript没有标准库。除了一些核心库外，没有文件系统的API，没有IO流API等。</li><li>JavaScript没有标准接口。没有如Web Server或者数据库的统一接口。</li><li>JavaScript没有包管理系统。不能自动加载和安装依赖。</li></ul><p>于是便有了CommonJS规范的出现，其目标是为了构建JavaScript在包括Web服务器，桌面，命令行工具，及浏览器方面的生态系统。</p><p>CommonJS制定了解决这些问题的一些规范，而Node.js就是这些规范的一种实现。Node.js自身实现了require方法作为其引入模块的方法，同时NPM也基于CommonJS定义的包规范，实现了依赖管理和模块自动安装等功能。这里我们将深入一下Node.js的require机制和NPM基于包规范的应用。</p><h2 id="简单模块定义和使用"><a href="#简单模块定义和使用" class="headerlink" title="简单模块定义和使用"></a>简单模块定义和使用</h2><p>在Node.js中，定义一个模块十分方便。我们以计算圆形的面积和周长两个方法为例，来表现Node.js中模块的定义方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PI = <span class="built_in">Math</span>.PI;</span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将这个文件存为circle.js，并新建一个app.js文件，并写入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'The area of a circle of radius 4 is '</span> + circle.area(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>可以看到模块调用也十分方便，只需要require需要调用的文件即可。</p><p>在require了这个文件之后，定义在exports对象上的方法便可以随意调用。Node.js将模块的定义和调用都封装得极其简单方便，从API对用户友好这一个角度来说，Node.js的模块机制是非常优秀的。</p><h2 id="模块载入策略"><a href="#模块载入策略" class="headerlink" title="模块载入策略"></a>模块载入策略</h2><p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。其中原生模块都被定义在lib这个目录下面，文件模块则不定性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>由于通过命令行加载启动的文件几乎都为文件模块。我们从Node.js如何加载文件模块开始谈起。加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bootstrap main module.</span></span><br><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Load the main module--the command line argument.</span></span><br><span class="line">    Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_load静态方法在分析文件名之后执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(id, parent);</span><br></pre></td></tr></table></figure><p>并根据文件路径缓存当前模块对象，该模块实例对象则根据文件名加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.load(filename);</span><br></pre></td></tr></table></figure><p>实际上在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。</p><ul><li>.js。通过fs模块同步读取js文件并编译执行。</li><li>.node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li><li>.json。读取文件，调用JSON.parse解析加载。</li></ul><p>这里我们将详细描述js后缀的编译过程。Node.js在编译js文件的过程中实际完成的步骤有对js文件内容进行头尾包装。以app.js为例，包装之后的app.js将会变成以下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The area of a circle of radius 4 is '</span> + circle.area(<span class="number">4</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码会通过vm原生模块的runInThisContext方法执行（类似eval，只是具有明确上下文，不污染全局），返回为一个具体的function对象。最后传入module对象的exports，require方法，module，文件名，目录名作为实参并执行。</p><p>这就是为什么require并没有定义在app.js 文件中，但是这个方法却存在的原因。从Node.js的API文档中可以看到还有<strong>filename、</strong>dirname、module、exports几个没有定义但是却存在的变量。其中<strong>filename和</strong>dirname在查找文件路径的过程中分析得到后传入的。module变量是这个模块对象自身，exports是在module的构造函数中初始化的一个空对象（{}，而不是null）。</p><p>在这个主文件中，可以通过require方法去引入其余的模块。而其实这个require方法实际调用的就是load方法。</p><p>load方法在载入、编译、缓存了module后，返回module的exports对象。这就是circle.js文件中只有定义在exports对象上的方法才能被外部调用的原因。</p><p>以上所描述的模块载入机制均定义在lib/module.js中。</p><h2 id="require方法中的文件查找策略"><a href="#require方法中的文件查找策略" class="headerlink" title="require方法中的文件查找策略"></a>require方法中的文件查找策略</h2><p>由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。</p><h2 id="从文件模块缓存中加载"><a href="#从文件模块缓存中加载" class="headerlink" title="从文件模块缓存中加载"></a>从文件模块缓存中加载</h2><p>尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。</p><h2 id="从原生模块加载"><a href="#从原生模块加载" class="headerlink" title="从原生模块加载"></a>从原生模块加载</h2><p>原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。</p><p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p><h2 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载"></a>从文件加载</h2><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p><p>require方法接受以下几种参数的传递：</p><ul><li>http、fs、path等，原生模块。</li><li>./mod或../mod，相对路径的文件模块。</li><li>/pathtomodule/mod，绝对路径的文件模块。</li><li>mod，非原生模块的文件模块。<br>在进入路径查找之前有必要描述一下module path这个Node.js中的概念。对于每一个被加载的文件模块，创建这个模块对象的时候，这个模块便会有一个paths属性，其值根据当前文件的路径计算得到。我们创建modulepath.js这样一个文件，其内容为：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br></pre></td></tr></table></figure><p>我们将其放到任意一个目录中执行node modulepath.js命令，将得到以下的输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'/home/jackson/research/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/jackson/node_modules'</span>,</span><br><span class="line"><span class="string">'/home/node_modules'</span>,</span><br><span class="line"><span class="string">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure><p>Windows下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'c:\\nodejs\\node_modules'</span>, <span class="string">'c:\\node_modules'</span> ]</span><br></pre></td></tr></table></figure><p>可以看出module path的生成规则为：从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。</p><p>除此之外还有一个全局module path，是当前node执行文件的相对目录（../../lib/node）。如果在环境变量中设置了HOME目录和NODE_PATH目录的话，整个路径还包含NODE_PATH和HOME目录下的.node_libraries与.node_modules。其最终值大致如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NODE_PATH，HOME/.node_modules，HOME/.node_libraries，execPath/../../lib/node]</span><br></pre></td></tr></table></figure><p>简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：</p><ol><li>从module path数组中取出第一个目录作为查找基准。</li><li>直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。</li><li>尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</li><li>尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。</li><li>尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。</li><li>如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。</li><li>如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。</li><li>如果仍然失败，则抛出异常。<br>整个查找过程十分类似原型链的查找和作用域的查找。所幸Node.js对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗。</li></ol><h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><p>前面提到，JavaScript缺少包结构。CommonJS致力于改变这种现状，于是定义了包的结构规范（<a href="http://wiki.commonjs.org/wiki/Packages/1.0" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Packages/1.0</a> ）。而NPM的出现则是为了在CommonJS规范的基础上，实现解决包的安装卸载，依赖管理，版本管理等问题。require的查找机制明了之后，我们来看一下包的细节。</p><p>一个符合CommonJS规范的包应该是如下这种结构：</p><ul><li>一个package.json文件应该存在于包顶级目录下</li><li>二进制文件应该包含在bin目录下。</li><li>JavaScript代码应该包含在lib目录下。</li><li>文档应该在doc目录下。</li><li><p>单元测试应该在test目录下。<br>由上文的require的查找过程可以知道，Node.js在没有找到目标文件时，会将当前目录当作一个包来尝试加载，所以在package.json文件中最重要的一个字段就是main。而实际上，这一处是Node.js的扩展，标准定义中并不包含此字段，对于require，只需要main属性即可。但是在除此之外包需要接受安装、卸载、依赖管理，版本管理等流程，所以CommonJS为package.json文件定义了如下一些必须的字段：</p></li><li><p>name。包名，需要在NPM上是唯一的。不能带有空格。</p></li><li>description。包简介。通常会显示在一些列表中。</li><li>version。版本号。一个语义化的版本号（<a href="http://semver.org/" target="_blank" rel="noopener">http://semver.org/</a> ），通常为x.y.z。该版本号十分重要，常常用于一些版本控制的场合。</li><li>keywords。关键字数组。用于NPM中的分类搜索。</li><li>maintainers。包维护者的数组。数组元素是一个包含name、email、web三个属性的JSON对象。</li><li>contributors。包贡献者的数组。第一个就是包的作者本人。在开源社区，如果提交的patch被merge进master分支的话，就应当加上这个贡献patch的人。格式包含name和email。如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"contributors"</span>: [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Jackson Tian"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"mail @gmail.com"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"fengmk2"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"mail2@gmail.com"</span></span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><ul><li>bugs。一个可以提交bug的URL地址。可以是邮件地址（mailto:mailxx@domain），也可以是网页地址（<a href="http://url）。" target="_blank" rel="noopener">http://url）。</a></li><li>licenses。包所使用的许可证。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"licenses"</span>: [&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://www.example.com/licenses/gpl.html"</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><ul><li>repositories。托管源代码的地址数组。</li><li>dependencies。当前包需要的依赖。这个属性十分重要，NPM会通过这个属性，帮你自动加载依赖的包。</li><li>以下是Express框架的package.json文件，值得参考。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"express"</span>,</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"Sinatra inspired web development framework"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"3.0.0alpha1-pre"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"TJ Holowaychuk</span></span><br></pre></td></tr></table></figure><p>除了前面提到的几个必选字段外，我们还发现了一些额外的字段，如bin、scripts、engines、devDependencies、author。这里可以重点提及一下scripts字段。包管理器（NPM）在对包进行安装或者卸载的时候需要进行一些编译或者清除的工作，scripts字段的对象指明了在进行操作时运行哪个文件，或者执行拿条命令。如下为一个较全面的scripts案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"install"</span>: <span class="string">"install.js"</span>,</span><br><span class="line">    <span class="string">"uninstall"</span>: <span class="string">"uninstall.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"build.js"</span>,</span><br><span class="line">    <span class="string">"doc"</span>: <span class="string">"make-doc.js"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"test.js"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你完善了自己的JavaScript库，使之实现了CommonJS的包规范，那么你可以通过NPM来发布自己的包，为NPM上5000+的基础上再加一个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish &lt;folder&gt;</span><br></pre></td></tr></table></figure><p>命令十分简单。但是在这之前你需要通过npm adduser命令在NPM上注册一个帐户，以便后续包的维护。NPM会分析该文件夹下的package.json文件，然后上传目录到NPM的站点上。用户在使用你的包时，也十分简明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package&gt;</span><br></pre></td></tr></table></figure><p>甚至对于NPM无法安装的包（因为某些奇怪的网络原因），可以通过github手动下载其稳定版本，解压之后通过以下命令进行安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package.json folder&gt;</span><br></pre></td></tr></table></figure><p>只需将路径指向package.json存在的目录即可。然后在代码中require(‘package’)即可使用。</p><p>Node.js中的require内部流程之复杂，而方法调用之简单，实在值得叹为观止。更多NPM使用技巧可以参见<a href="http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence。" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence。</a></p><h2 id="Node-js模块与前端模块的异同"><a href="#Node-js模块与前端模块的异同" class="headerlink" title="Node.js模块与前端模块的异同"></a>Node.js模块与前端模块的异同</h2><p>通常有一些模块可以同时适用于前后端，但是在浏览器端通过script标签的载入JavaScript文件的方式与Node.js不同。Node.js在载入到最终的执行中，进行了包装，使得每个文件中的变量天然的形成在一个闭包之中，不会污染全局变量。而浏览器端则通常是裸露的JavaScript代码片段。所以为了解决前后端一致性的问题，类库开发者需要将类库代码包装在一个闭包内。以下代码片段抽取自著名类库underscore的定义方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Establish the root object, `window` in the browser, or `global` on the server.</span></span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> wrapper(obj);</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">            exports = <span class="built_in">module</span>.exports = _;</span><br><span class="line">        &#125;</span><br><span class="line">        exports._ = _;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// Register as a named module with AMD.</span></span><br><span class="line">        define(<span class="string">'underscore'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root[<span class="string">'_'</span>] = _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>首先，它通过function定义构建了一个闭包，将this作为上下文对象直接call调用，以避免内部变量污染到全局作用域。续而通过判断exports是否存在来决定将局部变量<em>绑定给exports，并且根据define变量是否存在，作为处理在实现了AMD规范环境（<a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition）下的使用案例。仅只当处于浏览器的环境中的时候，this指向的是全局对象（window对象），才将" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition）下的使用案例。仅只当处于浏览器的环境中的时候，this指向的是全局对象（window对象），才将</a></em>变量赋在全局对象上，作为一个全局对象的方法导出，以供外部调用。</p><p>所以在设计前后端通用的JavaScript类库时，都有着以下类似的判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    exports.EventProxy = EventProxy;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.EventProxy = EventProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即，如果exports对象存在，则将局部变量挂载在exports对象上，如果不存在，则挂载在全局对象上。</p><p>对于更多前端的模块实现可以参考国内淘宝玉伯的seajs（<a href="http://seajs.com/），或者思科杜欢的oye（http://www.w3cgroup.com/oye/）。" target="_blank" rel="noopener">http://seajs.com/），或者思科杜欢的oye（http://www.w3cgroup.com/oye/）。</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.commonjs.org" target="_blank" rel="noopener">http://www.commonjs.org</a><br><a href="http://npmjs.org/doc/README.html" target="_blank" rel="noopener">http://npmjs.org/doc/README.html</a><br><a href="http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence</a><br><a href="http://nodejs.org/docs/latest/api/modules.html" target="_blank" rel="noopener">http://nodejs.org/docs/latest/api/modules.html</a></p>]]></content>
    
    <summary type="html">
    
      NodeJS
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 读书笔记 第1章</title>
    <link href="http://yoursite.com/2018/06/19/NodeJS%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E7%AC%AC1%E7%AB%A0/"/>
    <id>http://yoursite.com/2018/06/19/NodeJS 读书笔记 第1章/</id>
    <published>2018-06-19T10:00:00.000Z</published>
    <updated>2018-06-20T15:35:58.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h1><p>在Node中，异步I/O很常见。以读取文件为例。我们可以看到它与前端Ajax调用的方式是极其类似的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件完成'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'发起读取文件'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起读取文件</span></span><br><span class="line"><span class="comment">// 读取文件完成</span></span><br></pre></td></tr></table></figure><p>这里’发起读取文件’，是在读取文件完成之前执行的，这就是一个典型的异步。</p><p>在Node中，绝大多数的操作都以异步的方式进行调用。<a href="https://cn.linkedin.com/in/ryandahl01" title="Ryan dahl" target="_blank" rel="noopener">Ryan dahl</a>排除万难，在底层构建了很多异步I/O的API，<br>从文件读取到网络请求等，均是如此。这样做的意义是我们可以很自然的从语言层面进行并行I/O操作。每个调用之间<br>无需等待之前的I/O调用结束。在编程模型上可以极大提升效率。</p><p>下面的两个文件读取任务的耗时取决于最慢的那个文件读取耗时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件1完成'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件2完成'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而同步I/O这两个文件的耗时是两个任务耗时之和。</p><h1 id="事件与回掉函数"><a href="#事件与回掉函数" class="headerlink" title="事件与回掉函数"></a>事件与回掉函数</h1><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>典型的通过事件来暴露接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring=<span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"request already come"</span>);</span><br><span class="line">    <span class="keyword">var</span> post = <span class="string">""</span>;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        post =  querystring.parse(post);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'complete complished'</span>);</span><br><span class="line">        <span class="comment">//返回请求者一个信息</span></span><br><span class="line">        res.write(post.name);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>事件编程优点：</p><ul><li>轻量级</li><li>松耦合</li><li>只关注事物点</li></ul><p>事件编程缺点：</p><ul><li>在多个异步场景中，事件与事件之间相互独立，如何协作是一个问题</li></ul><h2 id="回掉函数"><a href="#回掉函数" class="headerlink" title="回掉函数"></a>回掉函数</h2><p>从上面例子可以看到回掉函数是无处不在的。这是因为在javaScript中，我们把函数看作为第一等攻门来对待，可以将函数作为对象传递给方法作为实参进行调用。</p><p>回掉函数优点：</p><ul><li>最好的接收异步调用返回数据的方法</li></ul><p>回掉函数缺点：</p><ul><li>易读性差（代码的编写顺序和执行顺序无关）</li><li>在流程控制方面，因为穿插了异步方法和回掉函数，与常规的同步方式相比变得不是那么一目了然</li></ul><h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>Node保持了javaScript在浏览器中的单线程的特点。</p><p>Node 单线程的弱点：</p><ul><li>无法利用多核 CPU</li><li>错误会引起整个应用退出，应用的健壮性值得考验</li><li>大量计算占用 CPU 导致无法继续调用异步 I/O</li></ul><p>Node 采用了 Web Workers 相同的思路来解决单线程过程中大计算量的问题： child_process。</p><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><p>Node 是基于libuv 实现跨平台的</p><h1 id="Node-善于处理-I-O-密集型，以及-CPU-密集型应用"><a href="#Node-善于处理-I-O-密集型，以及-CPU-密集型应用" class="headerlink" title="Node 善于处理 I/O 密集型，以及 CPU 密集型应用"></a>Node 善于处理 I/O 密集型，以及 CPU 密集型应用</h1><p>单线程同步编程模型会阻塞I/O导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁，状态同步等问题让开发人员头疼。<br>Node在两者之间给出了答案：利用单线程，远离多线程死锁，状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU。</p><h1 id="与遗留系统和平共处"><a href="#与遗留系统和平共处" class="headerlink" title="与遗留系统和平共处"></a>与遗留系统和平共处</h1><p>Node 非常适合利用原本的数据源，发挥异步并行的优势，来编写与前端交互的中间层。</p><p>比如国内的雪球财经，雪球财经是从原有的JAVA项目中分出来的一个子项目。在这个子项目中没有继续采用JAVA/JSP而是采用Node 来完成WEB端的开发，<br>使得前端工程师咋在HTTP协议栈的两端能够高效灵活的开发。避免了JAVA繁琐的表达；另一方面，又利用JAVA作为后端接口和中间件，使其具有良好的稳定性，两者互相结合，取长补短。</p><h1 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h1><p>因为非阻塞，反应迅速，而且拥有很好的网络库让网络节点之间实现通信，所以很好扩展，所谓快速、可伸缩嘛……很适合做分布式应用。</p><h1 id="Node-使用者"><a href="#Node-使用者" class="headerlink" title="Node 使用者"></a>Node 使用者</h1><p>前后端编程语言环境统一</p><ul><li>雅虎Cocktail</li></ul><p>Node带来的高性能I/O用于实时应用</p><ul><li>Voxer的实时语音</li><li>花瓣网</li><li>蘑菇街等公司通过socket.io实现实时通知的能力</li></ul><p>并行I/O使得使用者可以更高效地利用分布式环境</p><ul><li>阿里巴巴的NodeFox</li><li>eBay的ql.io</li></ul><p>并行I/O，有效利用稳定接口提升Web渲染能力</p><ul><li>雪球财经</li><li>LinkedIn的移动版网站</li></ul><p>云计算平台提供Node支持</p><ul><li>Joyent</li><li>Azure</li><li>阿里云</li><li>百度云</li></ul><p>游戏开发领域</p><ul><li>网易的pomelo</li></ul><p>工具类应用</p><ul><li>Browserify </li><li>grunt </li><li>gulp</li><li>less</li><li>uglifyjs</li><li>WebPack</li></ul>]]></content>
    
    <summary type="html">
    
      NodeJS
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="http://yoursite.com/2018/04/09/Vim/"/>
    <id>http://yoursite.com/2018/04/09/Vim/</id>
    <published>2018-04-09T10:53:49.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /[string]</span><br></pre></td></tr></table></figure><p>向光标之下寻找一个名称为 word 的字符串。</p><p>例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ?[string]</span><br></pre></td></tr></table></figure><p>向光标之上寻找一个字符串名称为 word 的字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ n</span><br></pre></td></tr></table></figure><p>这个 n 是英文按键。代表重复前一个搜寻的动作。</p><p>举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ N</span><br></pre></td></tr></table></figure><p>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。</p><p>例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</p><blockquote><p>高端玩法请看 <a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">Vim</a> 搜索替换章节</p></blockquote><h3 id="删除、复制与贴上"><a href="#删除、复制与贴上" class="headerlink" title="删除、复制与贴上"></a>删除、复制与贴上</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ x, X</span><br></pre></td></tr></table></figure><p>在一行字当中，x 为向后删除一个字符 (相当于 del 按键)， X 为向前删除一个字符(相当于 backspace 亦即是退格键) (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [number]x</span><br></pre></td></tr></table></figure><p>number 为数字，连续向后删除 number 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd</span><br></pre></td></tr></table></figure><p>删除游标所在的那一整行(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [number]dd</span><br></pre></td></tr></table></figure><p>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ d1G</span><br></pre></td></tr></table></figure><p>删除光标所在到第一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dG</span><br></pre></td></tr></table></figure><p>删除光标所在到最后一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ d$</span><br></pre></td></tr></table></figure><p>删除游标所在处，到该行的最后一个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ d0</span><br></pre></td></tr></table></figure><p>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yy</span><br></pre></td></tr></table></figure><p>复制游标所在的那一行(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nyy</span><br></pre></td></tr></table></figure><p>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ y1G</span><br></pre></td></tr></table></figure><p>复制游标所在行到第一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yG</span><br></pre></td></tr></table></figure><p>复制游标所在行到最后一行的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ y0</span><br></pre></td></tr></table></figure><p>复制光标所在的那个字符到该行行首的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ y$</span><br></pre></td></tr></table></figure><p>复制光标所在的那个字符到该行行尾的所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ p, P</span><br></pre></td></tr></table></figure><p>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ J</span><br></pre></td></tr></table></figure><p>将光标所在行与下一行的数据结合成同一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ c</span><br></pre></td></tr></table></figure><p>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ u</span><br></pre></td></tr></table></figure><p>复原前一个动作。(常用)</p><p>[Ctrl]+r    重做上一个动作。(常用)<br>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .</span><br></pre></td></tr></table></figure><p>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</p>]]></content>
    
    <summary type="html">
    
      抄录于菜鸟教程
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>WebStrom 快捷键</title>
    <link href="http://yoursite.com/2018/02/24/WebStrom-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/02/24/WebStrom-快捷键/</id>
    <published>2018-02-24T10:53:49.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <summary type="html">
    
      一堆神奇的快捷键
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>理解Object.defineProperty的作用</title>
    <link href="http://yoursite.com/2018/02/24/%E7%90%86%E8%A7%A3Object-defineProperty%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/24/理解Object-defineProperty的作用/</id>
    <published>2018-02-24T10:49:30.000Z</published>
    <updated>2018-04-30T04:42:37.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解Object-defineProperty的作用"><a href="#理解Object-defineProperty的作用" class="headerlink" title="理解Object.defineProperty的作用"></a>理解Object.defineProperty的作用</h1><ul><li>对象是由多个名/值对组成的无序的集合。对象中每个属性对应任意类型的值。</li><li><p>定义对象可以使用构造函数或字面量的形式：</p><pre><code>var obj = new Object;  //obj = {}obj.name = &quot;张三&quot;;  //添加描述obj.say = function(){};  //添加行为</code></pre><p>除了以上添加属性的方式，还可以使用Object.defineProperty定义新属性或修改原有的属性。</p></li></ul><hr><blockquote><p>Object.defineProperty()<br>语法：</p><p>Object.defineProperty(obj, prop, descriptor)<br>参数说明：</p></blockquote><ul><li>obj：必需。目标对象</li><li>prop：必需。需定义或修改的属性的名字</li><li><p>descriptor：必需。目标属性所拥有的特性<br>返回值：</p></li><li><p>传入函数的对象。即第一个参数obj<br>针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历。</p></li><li><p>给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。</p></li><li><p>数据描述<br>当修改或定义对象的某个属性的时候，给这个属性添加一些特性：</p><pre><code>var obj = {    test:&quot;hello&quot;}//对象已有的属性添加特性描述Object.defineProperty(obj,&quot;test&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});//对象新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,{    configurable:true | false,    enumerable:true | false,    value:任意类型的值,    writable:true | false});</code></pre></li><li><p>数据描述中的属性都是可选的，来看一下设置每一个属性的作用。</p></li></ul><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><ul><li><p>属性对应的值,可以使任意类型的值，默认为undefined</p><pre><code>var obj = {}//第一种情况：不设置value属性Object.defineProperty(obj,&quot;newKey&quot;,{});console.log( obj.newKey );  //undefined------------------------------//第二种情况：设置value属性Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;});console.log( obj.newKey );  //hellowritable</code></pre></li></ul><h2 id="属性的值是否可以被重写。"><a href="#属性的值是否可以被重写。" class="headerlink" title="属性的值是否可以被重写。"></a>属性的值是否可以被重写。</h2><ul><li><p>设置为true可以被重写；设置为false，不能被重写。默认为false。</p><pre><code>var obj = {}//第一种情况：writable设置为false，不能重写。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //hello//第二种情况：writable设置为true，可以重写Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true});//更改newKey的值obj.newKey = &quot;change value&quot;;console.log( obj.newKey );  //change valueenumerable</code></pre></li><li><p>此属性是否可以被枚举（使用for…in或Object.keys()）。</p></li><li><p>设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p><pre><code>var obj = {}//第一种情况：enumerable设置为false，不能被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false});//枚举对象的属性for( var attr in obj ){    console.log( attr );}//第二种情况：enumerable设置为true，可以被枚举。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:true});//枚举对象的属性for( var attr in obj ){    console.log( attr );  //newKey}</code></pre></li></ul><h2 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h2><ul><li>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。</li><li>设置为true可以被删除或可以重新设置特性；</li><li>设置为false，不能被可以被删除或不可以重新设置特性。默认为false。</li></ul><p><strong>这个属性起到两个作用：</strong></p><p>目标属性是否可以使用delete删除<br>目标属性是否可以再次设置特性</p><pre><code>//-----------------测试目标属性是否能被删除------------------------var obj = {}//第一种情况：configurable设置为false，不能被删除。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:false});//删除属性delete obj.newKey;console.log( obj.newKey ); //hello//第二种情况：configurable设置为true，可以被删除。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:true});//删除属性delete obj.newKey;console.log( obj.newKey ); //undefined//-----------------测试是否可以再次修改特性------------------------var obj = {}//第一种情况：configurable设置为false，不能再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:false});//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true,    enumerable:true,    configurable:true});console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey//第二种情况：configurable设置为true，可以再次修改特性。Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:false,    enumerable:false,    configurable:true});//重新修改特性Object.defineProperty(obj,&quot;newKey&quot;,{    value:&quot;hello&quot;,    writable:true,    enumerable:true,    configurable:true});console.log( obj.newKey ); //hello除了可以给新定义的属性设置特性，也可以给已有的属性设置特性//定义对象的时候添加的属性，是可删除、可重写、可枚举的。var obj = {    test:&quot;hello&quot;}//改写值obj.test = &apos;change value&apos;;console.log( obj.test ); //&apos;change value&apos;Object.defineProperty(obj,&quot;test&quot;,{    writable:false})//再次改写值obj.test = &apos;change value again&apos;;console.log( obj.test ); //依然是：&apos;change value&apos;提示：一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的falsevar obj = {};//定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false//这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性//Object.defineProperty(obj,&apos;newKey&apos;,{});//设置值obj.newKey = &apos;hello&apos;;console.log(obj.newKey);  //undefined//枚举for( var attr in obj ){    console.log(attr);}</code></pre><h2 id="设置的特性总结："><a href="#设置的特性总结：" class="headerlink" title="设置的特性总结："></a>设置的特性总结：</h2><blockquote><p>value: 设置属性的值</p><p>writable: 值是否可以重写。true | false</p><p>enumerable: 目标属性是否可以被枚举。true | false</p><p>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | &gt; false</p><p>存取器描述<br>当使用存取器描述属性的特性的时候，允许设置以下特性属性：</p></blockquote><pre><code>var obj = {};Object.defineProperty(obj,&quot;newKey&quot;,{    get:function (){} | undefined,    set:function (value){} | undefined    configurable: true | false    enumerable: true | false});</code></pre><p><strong>注意：当使用了getter或setter方法，不允许使用writable和value这两个属性</strong></p><h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter/setter"></a>getter/setter</h2><p>当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。</p><p>getter 是一种获得属性值的方法<br>setter是一种设置属性值的方法。<br>在特性中使用get/set属性来定义对应的方法。</p><pre><code>var obj = {};var initValue = &apos;hello&apos;;Object.defineProperty(obj,&quot;newKey&quot;,{    get:function (){        //当获取值的时候触发的函数        return initValue;    },    set:function (value){        //当设置值的时候触发的函数,设置的新值通过参数value拿到        initValue = value;    }});//获取值console.log( obj.newKey );  //hello//设置值obj.newKey = &apos;change value&apos;;console.log( obj.newKey ); //change value</code></pre><p><strong>注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined</strong></p><p>configurable和enumerable同上面的用法。</p>]]></content>
    
    <summary type="html">
    
      理解Object.defineProperty的作用
    
    </summary>
    
      <category term="javaScript" scheme="http://yoursite.com/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
      <category term="JS-Object" scheme="http://yoursite.com/tags/JS-Object/"/>
    
  </entry>
  
  <entry>
    <title>URL网址解析的好帮手</title>
    <link href="http://yoursite.com/2018/02/24/URL%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A5%BD%E5%B8%AE%E6%89%8B/"/>
    <id>http://yoursite.com/2018/02/24/URL网址解析的好帮手/</id>
    <published>2018-02-24T10:28:38.000Z</published>
    <updated>2018-06-19T14:47:44.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URI简介"><a href="#URI简介" class="headerlink" title="URI简介:"></a>URI简介:</h2><p>URI统一资源标识符<br>URL统一资源定位符<br>URL是URI的子集，URL肯定是URI,URI不一定是URL</p><h2 id="url地址组成"><a href="#url地址组成" class="headerlink" title="url地址组成:"></a>url地址组成:</h2><p><strong>protbcol</strong>:指定底层使用协议，http或ftp等<br><strong>slashes</strong>:是否有协议的双斜线<br><strong>host</strong>:http的IP地址或域名<br><strong>port</strong>:端口<br><strong>hostname</strong>:主机名<br><strong>hash</strong>:哈希值<br><strong>search</strong>:查询字符串参数<br><strong>query</strong>:发送给http的数据，参数串<br><strong>pathname</strong>:访问资源路径名<br><strong>path</strong>:路径<br><strong>href</strong>:超链接</p><h2 id="解析url"><a href="#解析url" class="headerlink" title="解析url:"></a>解析url:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ url.parse(URL)</span><br><span class="line"></span><br><span class="line">$ url.parse(<span class="string">'https://www.imooc.com/course/list?c=nodejs'</span>)</span><br><span class="line"></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">'https:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'www.imooc.com'</span>,</span><br><span class="line">  port: null,</span><br><span class="line">  hostname: <span class="string">'www.imooc.com'</span>,</span><br><span class="line">  <span class="built_in">hash</span>: null,</span><br><span class="line">  search: <span class="string">'?c=nodejs'</span>,</span><br><span class="line">  query: <span class="string">'c=nodejs'</span>,</span><br><span class="line">  pathname: <span class="string">'/course/list'</span>,</span><br><span class="line">  path: <span class="string">'/course/list?c=nodejs'</span>,</span><br><span class="line">  href: <span class="string">'https://www.imooc.com/course/list?c=nodejs'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反解析"><a href="#反解析" class="headerlink" title="反解析:"></a>反解析:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format(OBJ)</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">querystring.stringify(obj,para1,para2)//将对象转化成url中query部分的形式（序列化）</span><br></pre></td></tr></table></figure><p>参数：<br>    1.要转化的对象<br>    2.链接符（默认&amp;）<br>    3.键与值之间的符号（默认=）</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">querystring.parse(string,para1,para2)//将query字符串转化成对象（反序列化）</span><br></pre></td></tr></table></figure><p>参数：<br>    1.query字符串<br>    2.链接符（默认&amp;）<br>    3.键与值之间的符号（默认=）<br>    4.参数的个数（默认最多1000个，0就没有限制）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">querystring.escape(string)//文字转译</span><br><span class="line">querystring.unescape(string)//反转译</span><br></pre></td></tr></table></figure></p><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>DNS 域名系统 (Domain Name System) 的缩写</p><p>http客户端发起请求，创建端口<br>http服务器在端口监听客户端请求<br>http服务器向客户端返回状态和内容<br>请求和响应都发送 http 头和正文信息，http 头发送内容类型、http 状态码，正文是提交的数据或者服务器返回的数据<br>1.chrome搜索自身的DNS缓存<br>2.搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）<br>3.读取本地的host文件<br>4.浏览器发起一个DNS的一个系统调用：①宽带运营商服务器查看本身缓存；②运营商服务器发起一个迭代DNS解析的请求；③运营商服务器把结果返回操作系统内核同时缓存起来，④操作系统内核把结果返回浏览器；⑤最终浏览器拿到了目标网站对应的IP地址<br>5.浏览器获得域名对应ip地址后，发起HTTP“三次握手”<br>6.TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了。<br>7.服务器端接受到这个请求，根据路径参数，经过后端处理后，把处理后的一个结果的数据返回给浏览器。<br>8.浏览器获取到目标网址的数据，例如返回一个HTML文件,HTML文档内的JS/CSS/图片静态资源同样也是一个个HTTP请求，也要包括上述步骤。<br>9.浏览器根据获取到的资源对页面进行渲染，最终把网页呈献给用户</p><h2 id="http头和正文信息"><a href="#http头和正文信息" class="headerlink" title="http头和正文信息"></a>http头和正文信息</h2><p>HTTP头发送的是一些附加的信息：内容类型、服务器发送相应的日期、HTTP状态码</p><p>正文就是用户提交的表单数据。</p>]]></content>
    
    <summary type="html">
    
      node 中 url 解析以及反解析
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>微信JSDK开发问题总结</title>
    <link href="http://yoursite.com/2018/02/24/%E5%BE%AE%E4%BF%A1JSDK%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/24/微信JSDK开发问题总结/</id>
    <published>2018-02-24T10:08:36.000Z</published>
    <updated>2018-04-30T04:42:37.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤一：绑定域名"><a href="#步骤一：绑定域名" class="headerlink" title="步骤一：绑定域名"></a>步骤一：绑定域名</h2><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。<br>备注：登录后可在“开发者中心”查看对应的接口权限。</p><h2 id="步骤二：引入JS文件"><a href="#步骤二：引入JS文件" class="headerlink" title="步骤二：引入JS文件"></a>步骤二：引入JS文件</h2><p>Github地址 <a href="https://github.com/yanxi-me/weixin-js-sdk" target="_blank" rel="noopener">https://github.com/yanxi-me/weixin-js-sdk</a><br>在需要调用JS接口的页面引入如下JS文件（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.2.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.2.0.js</a><br>备注：支持使用 AMD/CMD 标准模块加载方法加载</p><h2 id="步骤三：通过config接口注入权限验证配置"><a href="#步骤三：通过config接口注入权限验证配置" class="headerlink" title="步骤三：通过config接口注入权限验证配置"></a>步骤三：通过config接口注入权限验证配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$wx</span>.config(&#123;</span><br><span class="line">  debug: <span class="literal">false</span>, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过<span class="built_in">log</span>打出，仅在pc端时才会打印。</span><br><span class="line">  appId: APPID, // 必填，公众号的唯一标识</span><br><span class="line">  timestamp: data[<span class="string">'timestamp'</span>], // 必填，生成签名的时间戳</span><br><span class="line">  nonceStr: data[<span class="string">'noncestr'</span>], // 必填，生成签名的随机串</span><br><span class="line">  signature: data[<span class="string">'signature'</span>], // 必填，签名，见附录1</span><br><span class="line">  jsApiList: [<span class="string">'scanQRCode'</span>] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调试的时候一定要打开 debug 看报错检查问题</p><h2 id="步骤四：通过ready接口处理成功验证"><a href="#步骤四：通过ready接口处理成功验证" class="headerlink" title="步骤四：通过ready接口处理成功验证"></a>步骤四：通过ready接口处理成功验证</h2><p>wx.ready(function(){<br>    // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。<br>});</p><h2 id="步骤五：通过error接口处理失败验证"><a href="#步骤五：通过error接口处理失败验证" class="headerlink" title="步骤五：通过error接口处理失败验证"></a>步骤五：通过error接口处理失败验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wx.error(<span class="keyword">function</span>(res)&#123;</span><br><span class="line">    // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span><br><span class="line">&#125;);</span><br><span class="line">this.<span class="variable">$wx</span>.checkJsApi(&#123;</span><br><span class="line">  jsApiList: [</span><br><span class="line">    <span class="string">'scanQRCode'</span></span><br><span class="line">  ],</span><br><span class="line">  success: <span class="keyword">function</span> (res) &#123;</span><br><span class="line">    console.log(JSON.stringify(res))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">this.<span class="variable">$wx</span>.scanQRCode(&#123;</span><br><span class="line">  needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，</span><br><span class="line">  scanType: [<span class="string">'qrCode'</span>, <span class="string">'barCode'</span>], // 可以指定扫二维码还是一维码，默认二者都有</span><br><span class="line">  success: <span class="keyword">function</span> (res) &#123;</span><br><span class="line">    <span class="built_in">let</span> result = res.resultStr // 当needResult 为 1 时，扫码返回的结果</span><br><span class="line">    console.log(result)</span><br><span class="line">    alert(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>重点：一定要检查 appid 是否与后台相同</strong><br><strong>一定要检查当前插件是否能够启用</strong></p>]]></content>
    
    <summary type="html">
    
      微信JSDK开发问题总结
    
    </summary>
    
      <category term="微信" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1/"/>
    
    
      <category term="微信开发" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2018/01/31/python/"/>
    <id>http://yoursite.com/2018/01/31/python/</id>
    <published>2018-01-31T09:50:48.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中数据类型"><a href="#Python中数据类型" class="headerlink" title="Python中数据类型"></a>Python中数据类型</h1><h2 id="一、整数"><a href="#一、整数" class="headerlink" title="一、整数"></a>一、整数</h2><p> Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><h2 id="二、浮点数"><a href="#二、浮点数" class="headerlink" title="二、浮点数"></a>二、浮点数</h2><p> 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p> 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h2 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h2><p> 字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p><h2 id="四、布尔值"><a href="#四、布尔值" class="headerlink" title="四、布尔值"></a>四、布尔值</h2><p> 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p><p> 布尔值可以用and、or和not运算。</p><p> and运算是与运算，只有所有都为 True，and运算结果才是 True。</p><p> or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p><p> not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p><h2 id="五、空值"><a href="#五、空值" class="headerlink" title="五、空值"></a>五、空值</h2><p> 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><p> 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到</p><hr><hr><h1 id="Python之print语句"><a href="#Python之print语句" class="headerlink" title="Python之print语句"></a>Python之print语句</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'hello, python.'</span>)</span><br><span class="line">hello, python</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello,'</span> + <span class="string">'python.'</span>)</span><br><span class="line">hello, python</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python的注释"><a href="#Python的注释" class="headerlink" title="Python的注释"></a>Python的注释</h1><p> 任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。</p><p> Python的注释以 # 开头，后面的文字直到行尾都算注释</p><hr><hr><h1 id="Python中什么是变量"><a href="#Python中什么是变量" class="headerlink" title="Python中什么是变量"></a>Python中什么是变量</h1><p> 在Python中，变量的概念基本上和初中代数的方程变量是一致的。</p><p> 例如，对于方程式 y=x*x ，x就是变量。当x=2时，计算结果是4，当x=5时，计算结果是25。</p><p> 只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p> 在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line"><span class="built_in">print</span>(a) // 1</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中定义字符串"><a href="#Python中定义字符串" class="headerlink" title="Python中定义字符串"></a>Python中定义字符串</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python was started in 1989 by \"Guido\".\nPython is free and easy to learn.'</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line"></span><br><span class="line">Python was started <span class="keyword">in</span> 1989 by <span class="string">"Guido"</span>.</span><br><span class="line">Python is free and easy to learn.</span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中raw字符串与多行字符串"><a href="#Python中raw字符串与多行字符串" class="headerlink" title="Python中raw字符串与多行字符串"></a>Python中raw字符串与多行字符串</h1><p> 如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r<span class="string">'\(~_~)/ \(~_~)/'</span></span><br></pre></td></tr></table></figure><p> 但是r’…’表示法不能表示多行字符串，也不能表示包含’和 “的字符串（为什么？）</p><p> 如果要表示多行字符串，可以用’’’…’’’表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span><span class="string">'Line 1</span></span><br><span class="line"><span class="string">Line 2</span></span><br><span class="line"><span class="string">Line 3'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p> 还可以在多行字符串前面添加 r ，把这个多行字符串也变成一个raw字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r<span class="string">''</span><span class="string">'Python is created by "Guido".</span></span><br><span class="line"><span class="string">It is free and easy to learn.</span></span><br><span class="line"><span class="string">Let'</span>s start learn Python <span class="keyword">in</span> imooc!<span class="string">''</span><span class="string">'</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中Unicode字符串"><a href="#Python中Unicode字符串" class="headerlink" title="Python中Unicode字符串"></a>Python中Unicode字符串</h1><p> 字符串还有一个编码问题。</p><p> 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。</p><p> 如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p><p> 类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p> Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p><p> 因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。</p><p> Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> u<span class="string">'中文'</span></span><br><span class="line">中文</span><br></pre></td></tr></table></figure><p> 注意: 不加 u ，中文就不能正常显示。<br> Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p><p> 转义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u<span class="string">'中文\n日文\n韩文'</span></span><br></pre></td></tr></table></figure><p> 多行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u<span class="string">''</span><span class="string">'第一行</span></span><br><span class="line"><span class="string">第二行'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p> raw+多行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ur<span class="string">''</span><span class="string">'Python的Unicode字符串支持"中文",</span></span><br><span class="line"><span class="string">"日文",</span></span><br><span class="line"><span class="string">"韩文"等多种语言'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p> 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p> 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">''</span><span class="string">'静夜思</span></span><br><span class="line"><span class="string">床前明月光，</span></span><br><span class="line"><span class="string">疑是地上霜。</span></span><br><span class="line"><span class="string">举头望明月，</span></span><br><span class="line"><span class="string">低头思故乡。'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中整数和浮点数"><a href="#Python中整数和浮点数" class="headerlink" title="Python中整数和浮点数"></a>Python中整数和浮点数</h1><p> Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。</p><p> 基本的运算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 + 3   <span class="comment"># ==&gt; 6</span></span><br><span class="line">4 * 5 - 6   <span class="comment"># ==&gt; 14</span></span><br><span class="line">7.5 / 8 + 2.1   <span class="comment"># ==&gt; 3.0375</span></span><br></pre></td></tr></table></figure><p> 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1 + 2) * 3    <span class="comment"># ==&gt; 9</span></span><br><span class="line">(2.2 + 3.3) / (1.5 * (9 - 0.3))    <span class="comment"># ==&gt; 0.42145593869731807</span></span><br></pre></td></tr></table></figure><p> 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 2    <span class="comment"># ==&gt; 整数 3</span></span><br><span class="line">1.0 + 2.0    <span class="comment"># ==&gt; 浮点数 3.0</span></span><br></pre></td></tr></table></figure><p> 但是整数和浮点数混合运算的结果就变成浮点数了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2.0    <span class="comment"># ==&gt; 浮点数 3.0</span></span><br></pre></td></tr></table></figure><p> 为什么要区分整数运算和浮点数运算呢？这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如 0.1 换成二进制表示就是无限循环小数。</p><p> 那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 / 4    <span class="comment"># ==&gt; 2</span></span><br></pre></td></tr></table></figure><p> 令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 % 4    <span class="comment"># ==&gt; 3</span></span><br></pre></td></tr></table></figure><p> 如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11.0 / 4    <span class="comment"># ==&gt; 2.75</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Python中布尔类型"><a href="#Python中布尔类型" class="headerlink" title="Python中布尔类型"></a>Python中布尔类型</h1><p> 我们已经了解了Python支持布尔类型的数据，布尔类型只有True和False两种值，但是布尔类型有以下几种运算：</p><p> 与运算：只有两个布尔值都为 True 时，计算结果才为 True。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True and True   <span class="comment"># ==&gt; True</span></span><br><span class="line">True and False   <span class="comment"># ==&gt; False</span></span><br><span class="line">False and True   <span class="comment"># ==&gt; False</span></span><br><span class="line">False and False   <span class="comment"># ==&gt; False</span></span><br></pre></td></tr></table></figure><p> 或运算：只要有一个布尔值为 True，计算结果就是 True。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True or True   <span class="comment"># ==&gt; True</span></span><br><span class="line">True or False   <span class="comment"># ==&gt; True</span></span><br><span class="line">False or True   <span class="comment"># ==&gt; True</span></span><br><span class="line">False or False   <span class="comment"># ==&gt; False</span></span><br></pre></td></tr></table></figure><p> 非运算：把True变为False，或者把False变为True：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">not True   <span class="comment"># ==&gt; False</span></span><br><span class="line">not False   <span class="comment"># ==&gt; True</span></span><br></pre></td></tr></table></figure><p> 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。</p><p> 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = True</span><br><span class="line"><span class="built_in">print</span> a and <span class="string">'a=T'</span> or <span class="string">'a=F'</span></span><br></pre></td></tr></table></figure><p> 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？</p><p> 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以：</p><p> True and ‘a=T’ 计算结果是 ‘a=T’<br> 继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’<br> 要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。</p><blockquote><ol><li><p>在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。</p></li><li><p>在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。</p></li></ol></blockquote><p> 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。</p>]]></content>
    
    <summary type="html">
    
      python 学习小文档
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>cordova</title>
    <link href="http://yoursite.com/2018/01/29/cordova/"/>
    <id>http://yoursite.com/2018/01/29/cordova/</id>
    <published>2018-01-29T03:04:13.000Z</published>
    <updated>2018-04-30T04:42:37.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cordova中文文档"><a href="#cordova中文文档" class="headerlink" title="cordova中文文档"></a><a href="http://cordova.axuer.com/docs/zh-cn/latest/" title="cordova中文文档" target="_blank" rel="noopener">cordova</a>中文文档</h1><h2 id="安装-cordova"><a href="#安装-cordova" class="headerlink" title="安装 cordova"></a>安装 cordova</h2><p>Cordova命令行工具作为npm包分发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cordova -g</span><br></pre></td></tr></table></figure><h2 id="创建App"><a href="#创建App" class="headerlink" title="创建App"></a>创建App</h2><p>跳转到你维护源代码的目录中，并创建你的cordova项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova create hello com.example.hello HelloWorld</span><br></pre></td></tr></table></figure><ul><li>第一个参数是项目目录</li><li>第二个参数是 app 名称 </li><li>第三个参数是项目名称</li></ul><h2 id="添加平台"><a href="#添加平台" class="headerlink" title="添加平台"></a>添加平台</h2><p>所有后续命令都需要在项目目录或者项目目录的任何子目录运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hello</span><br></pre></td></tr></table></figure><p>给你的App添加目标平台。我们将会添加’ios’和’android’平台，并确保他们保存在了config.xml中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cordova platform add ios --save</span><br><span class="line">$ cordova platform add android --save</span><br></pre></td></tr></table></figure><h3 id="检查你当前平台设置状况"><a href="#检查你当前平台设置状况" class="headerlink" title="检查你当前平台设置状况:"></a>检查你当前平台设置状况:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova platform ls</span><br></pre></td></tr></table></figure><h2 id="安装构建先决条件"><a href="#安装构建先决条件" class="headerlink" title="安装构建先决条件"></a>安装构建先决条件</h2><p>要构建和运行App，你需要安装每个你需要平台的SDK。另外，当你使用浏览器开发你可以添加 browser平台，它不需要任何平台SDK。</p><p>检测你是否满足构建平台的要求:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cordova requirements</span><br><span class="line"></span><br><span class="line">Requirements check results <span class="keyword">for</span> android:</span><br><span class="line">Java JDK: installed .</span><br><span class="line">Android SDK: installed</span><br><span class="line">Android target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23</span><br><span class="line">Gradle: installed</span><br><span class="line"></span><br><span class="line">Requirements check results <span class="keyword">for</span> ios:</span><br><span class="line">Apple OS X: not installed</span><br><span class="line">Cordova tooling <span class="keyword">for</span> iOS requires Apple OS X</span><br><span class="line">Error: Some of requirements check failed</span><br></pre></td></tr></table></figure><h2 id="构建App"><a href="#构建App" class="headerlink" title="构建App"></a>构建App</h2><p>默认情况下, <strong>cordova create</strong>生产基于web应用程序的骨架，项目开始页面位于<strong>www/index.html</strong> 文件。任何初始化任务应该在<strong>www/js/index.js</strong>文件中的deviceready事件的事件处理函数中。</p><p>运行下面命令为所有添加的平台构建:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build</span><br></pre></td></tr></table></figure><p>你可以在每次构建中选择限制平台范围 - 这个例子中是’ios’:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build ios</span><br></pre></td></tr></table></figure><h2 id="查看插件列表"><a href="#查看插件列表" class="headerlink" title="查看插件列表"></a>查看插件列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova plugin ls</span><br></pre></td></tr></table></figure><h2 id="查看插件列表-1"><a href="#查看插件列表-1" class="headerlink" title="查看插件列表"></a>查看插件列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova plugin add &lt;插件名称 例子&gt;</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova run android</span><br></pre></td></tr></table></figure><h2 id="生成发布版app"><a href="#生成发布版app" class="headerlink" title="生成发布版app"></a>生成发布版app</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cordova build --release</span><br></pre></td></tr></table></figure><h2 id="Adb安装应用程序"><a href="#Adb安装应用程序" class="headerlink" title="Adb安装应用程序"></a>Adb安装应用程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb  install + app路径</span><br></pre></td></tr></table></figure><p>例：</p><blockquote><p>add install /Users/deepera/ws/cordova/client/platforms/android/build/outputs/apk/android-release.apk</p></blockquote><h2 id="查看链接设备"><a href="#查看链接设备" class="headerlink" title="查看链接设备"></a>查看链接设备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      cordova 环境搭建以及基本指令
    
    </summary>
    
      <category term="cordova" scheme="http://yoursite.com/categories/cordova/"/>
    
    
      <category term="cordova" scheme="http://yoursite.com/tags/cordova/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux shell</title>
    <link href="http://yoursite.com/2018/01/23/Linux-shell/"/>
    <id>http://yoursite.com/2018/01/23/Linux-shell/</id>
    <published>2018-01-23T10:57:42.000Z</published>
    <updated>2018-04-30T04:42:37.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf demo.txt</span><br></pre></td></tr></table></figure><p><strong>-rf</strong>:强制删除并且不提醒</p><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> [dirName]</span><br></pre></td></tr></table></figure><p><strong>dirName</strong>：要切换的目标目录。</p><h3 id="查看一个文件"><a href="#查看一个文件" class="headerlink" title="查看一个文件"></a>查看一个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br></pre></td></tr></table></figure><h3 id="触碰一个文件"><a href="#触碰一个文件" class="headerlink" title="触碰一个文件"></a>触碰一个文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch demo.txt</span><br></pre></td></tr></table></figure><p><strong>如果没有这个文件则新建</strong></p><h3 id="新建一个文件夹"><a href="#新建一个文件夹" class="headerlink" title="新建一个文件夹"></a>新建一个文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir demo</span><br></pre></td></tr></table></figure><h2 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h2><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><p><strong>端口号</strong>: -P2222</p><p><strong>username</strong>: root</p><p><strong>IP</strong>: 47.94.238.16</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -P2222 root@47.94.238.16</span><br></pre></td></tr></table></figure><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>-A 　显示所有程序。 </p><p>-e 　此参数的效果和指定”A”参数相同。</p><p>-f 　显示<a href="https://www.baidu.com/s?wd=UID&amp;tn=67012150_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrjb0T1Y1n16krjF9nHn3uhuBuynv0ZwV5fKWUMw85HmLnjDznHRsgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPW6sPjmLPWR1njDsrjRsn1Tz" target="_blank" rel="noopener">UID</a>,PPIP,C与S<a href="https://www.baidu.com/s?wd=TIME&amp;tn=67012150_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrjb0T1Y1n16krjF9nHn3uhuBuynv0ZwV5fKWUMw85HmLnjDznHRsgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPW6sPjmLPWR1njDsrjRsn1Tz" target="_blank" rel="noopener">TIME</a>栏位。 </p><p>grep命令是查找</p><p>中间的|是管道命令</p><p>是指ps命令与grep同时执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep java</span><br></pre></td></tr></table></figure><h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h3><blockquote><p><strong>-9强制杀掉进程</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 java_id</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><blockquote><p><strong>-r</strong> 可以上传文件夹</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -p2222 -r demo.txt root@47.94.238.16:/usr/<span class="built_in">local</span>/tomcat/tomcat_api/webapps</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      linux 命令汇总
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
</feed>
